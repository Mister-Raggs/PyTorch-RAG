{
  "doc_id": "037b6890ba8e7c282bdd4c60888b6e64",
  "source": "pytorch_docs",
  "title": "Numerical accuracy \u2014 PyTorch 2.9 documentation",
  "text": "\n## Numerical accuracy#\n\nCreated On: Oct 13, 2021 | Last Updated On: Jul 16, 2025\nIn modern computers, floating point numbers are represented using IEEE 754 standard.\nFor more details on floating point arithmetic and IEEE 754 standard, please seeFloating point arithmeticIn particular, note that floating point provides limited accuracy (about 7 decimal digits\nfor single precision floating point numbers, about 16 decimal digits for double precision\nfloating point numbers) and that floating point addition and multiplication are not\nassociative, so the order of the operations affects the results.\nBecause of this, PyTorch is not guaranteed\nto produce bitwise identical results for floating point computations that are\nmathematically identical. Similarly, bitwise identical results are not guaranteed across\nPyTorch releases, individual commits, or different platforms. In particular, CPU and GPU\nresults can be different even for bitwise-identical inputs and even after controlling for\nthe sources of randomness.\n\n## Batched computations or slice computations#\n\nMany operations in PyTorch support batched computation, where the same operation is performed\nfor the elements of the batches of inputs. An example of this istorch.mm()andtorch.bmm(). It is possible to implement batched computation as a loop over batch elements,\nand apply the necessary math operations to the individual batch elements, for efficiency reasons\nwe are not doing that, and typically perform computation for the whole batch. The mathematical\nlibraries that we are calling, and PyTorch internal implementations of operations can produces\nslightly different results in this case, compared to non-batched computations. In particular,\nletAandBbe 3D tensors with the dimensions suitable for batched matrix multiplication.\nThen(A@B)[0](the first element of the batched result) is not guaranteed to be bitwise\nidentical toA[0]@B[0](the matrix product of the first elements of the input batches)\neven though mathematically it\u2019s an identical computation.\ntorch.mm()\ntorch.bmm()\nA\nB\n(A@B)[0]\nA[0]@B[0]\nSimilarly, an operation applied to a tensor slice is not guaranteed to produce results that are\nidentical to the slice of the result of the same operation applied to the full tensor. E.g. letAbe a 2-dimensional tensor.A.sum(-1)[0]is not guaranteed to be bitwise equal toA[:,0].sum().\nA\nA.sum(-1)[0]\nA[:,0].sum()\n\n## Extremal values#\n\nWhen inputs contain large values such that intermediate results may overflow the range of the\nused datatype, the end result may overflow too, even though it is representable in the original\ndatatype. E.g.:\n\n```python\nimport torch\na=torch.tensor([1e20, 1e20]) # fp32 type by default\na.norm() # produces tensor(inf)\na.double().norm() # produces tensor(1.4142e+20, dtype=torch.float64), representable in fp32\n\n```\n\n\n## Linear algebra (torch.linalg)#\n\ntorch.linalg\n\n## Non-finite values#\n\nThe external libraries (backends) thattorch.linalguses provide no guarantees on their behaviour\nwhen the inputs have non-finite values likeinforNaN. As such, neither does PyTorch.\nThe operations may return a tensor with non-finite values, or raise an exception, or even segfault.\ntorch.linalg\ninf\nNaN\nConsider usingtorch.isfinite()before calling these functions to detect this situation.\ntorch.isfinite()\n\n## Extremal values in linalg#\n\nFunctions withintorch.linalghave moreExtremal Valuesthan other PyTorch functions.\ntorch.linalg\nSolversandInversesassume that the input matrixAis invertible. If it is close to\nbeing non-invertible (for example, if it has a very small singular value), then these algorithms may silently return\nincorrect results. These matrices are said to beill-conditioned.\nIf provided with ill-conditioned inputs, the result of these functions they may vary when using the same inputs on different\ndevices or when using different backends via the keyworddriver.\nA\ndriver\nSpectral operations likesvd,eig, andeighmay also return incorrect results (and their gradients may be infinite)\nwhen their inputs have singular values that are close to each other. This is because the algorithms used to compute these decompositions\nstruggle to converge for these inputs.\nsvd\neig\neigh\nRunning the computation infloat64(as NumPy does by default) often helps, but it does not solve these issues in all cases.\nAnalyzing the spectrum of the inputs viatorch.linalg.svdvals()or their condition number viatorch.linalg.cond()may help to detect these issues.\nfloat64\ntorch.linalg.svdvals()\ntorch.linalg.cond()\n\n## TensorFloat-32(TF32) on Nvidia Ampere (and later) devices#\n\nOn Ampere (and later) Nvidia GPUs, PyTorch can use TensorFloat32 (TF32) to speed up mathematically intensive operations, in particular matrix multiplications and convolutions.\nWhen an operation is performed using TF32 tensor cores, only the first 10 bits of the input mantissa are read.\nThis may reduce accuracy and produce surprising results (e.g., multiplying a matrix by the identity matrix may produce results that are different from the input).\nBy default, TF32 tensor cores are disabled for matrix multiplications and enabled for convolutions, although most neural network workloads have the same convergence behavior when using TF32 as they have with fp32.\nWe recommend enabling TF32 tensor cores for matrix multiplications withtorch.backends.cuda.matmul.fp32_precision=\"tf32\"(`torch.backends.cuda.matmul.allow_tf32=Trueis going to be deprecated) if your network does not need full float32 precision.\nIf your network needs full float32 precision for both matrix multiplications and convolutions, then TF32 tensor cores can also be disabled for convolutions withtorch.backends.cudnn.conv.fp32_precision=\"ieee\"(torch.backends.cudnn.allow_tf32=Falseis going to be deprecated).\ntorch.backends.cuda.matmul.fp32_precision=\"tf32\"\n`torch.backends.cuda.matmul.allow_tf32=True\ntorch.backends.cudnn.conv.fp32_precision=\"ieee\"\ntorch.backends.cudnn.allow_tf32=False\nFor more information seeTensorFloat32.\n\n## Reduced Precision Reduction for FP16 and BF16 GEMMs#\n\nHalf-precision GEMM operations are typically done with intermediate accumulations (reduction) in single-precision for numerical accuracy and improved resilience to overflow. For performance, certain GPU architectures, especially more recent ones, allow a few truncations of the intermediate accumulation results to the reduced precision (e.g., half-precision). This change is often benign from the perspective of model convergence, though it may lead to unexpected results (e.g.,infvalues when the final result should be be representable in half-precision).\nIf reduced-precision reductions are problematic, they can be turned off withtorch.backends.cuda.matmul.allow_fp16_reduced_precision_reduction=False\ninf\ntorch.backends.cuda.matmul.allow_fp16_reduced_precision_reduction=False\nA similar flag exists for BF16 GEMM operations and is turned on by default. If BF16\nreduced-precision reductions are problematic, they can be turned off withtorch.backends.cuda.matmul.allow_bf16_reduced_precision_reduction=False\ntorch.backends.cuda.matmul.allow_bf16_reduced_precision_reduction=False\nFor more information seeallow_fp16_reduced_precision_reductionandallow_bf16_reduced_precision_reduction\n\n## Reduced Precision Reduction for FP16 and BF16 in Scaled Dot Product Attention (SDPA)#\n\nA naive SDPA math backend, when using FP16/BF16 inputs, can accumulate significant numerical errors due to the usage of low-precision intermediate buffers. To mitigate this issue, the default behavior now involves upcasting FP16/BF16 inputs to FP32. Computations are performed in FP32/TF32, and the final FP32 results are then downcasted back to FP16/BF16. This will improve numerical accuracy of the final output for the math backend with FP16/BF16 inputs, but increases memory usages and may cause the performance regressions in the math backend as computations shift from FP16/BF16 BMM to FP32/TF32 BMM/Matmul.\nFor scenarios where reduced-precision reductions are preferred for speed, they can be enabled with the following setting:torch.backends.cuda.allow_fp16_bf16_reduction_math_sdp(True)\ntorch.backends.cuda.allow_fp16_bf16_reduction_math_sdp(True)\n\n## Reduced Precision FP16 and BF16 GEMMs and Convolutions on AMD Instinct MI200 devices#\n\nOn AMD Instinct MI200 GPUs, the FP16 and BF16 V_DOT2 and MFMA matrix instructions flush input and output denormal values to zero. FP32 and FP64 MFMA matrix instructions do not flush input and output denormal values to zero. The affected instructions are only used by rocBLAS (GEMM) and MIOpen (convolution) kernels; all other PyTorch operations will not encounter this behavior. All other supported AMD GPUs will not encounter this behavior.\nrocBLAS and MIOpen provide alternate implementations for affected FP16 operations. Alternate implementations for BF16 operations are not provided; BF16 numbers have a larger dynamic range than FP16 numbers and are less likely to encounter denormal values. For the FP16 alternate implementations, FP16 input values are cast to an intermediate BF16 value and then cast back to FP16 output after the accumulate FP32 operations. In this way, the input and output types are unchanged.\nWhen training using FP16 precision, some models may fail to converge with FP16 denorms flushed to zero. Denormal values more frequently occur in the backward pass of training during gradient calculation. PyTorch by default will use the rocBLAS and MIOpen alternate implementations during the backward pass. The default behavior can be overridden using environment variables, ROCBLAS_INTERNAL_FP16_ALT_IMPL and MIOPEN_DEBUG_CONVOLUTION_ATTRIB_FP16_ALT_IMPL. The behavior of these environment variables is as follows:\nforward\nbackward\nEnv unset\noriginal\nalternate\nEnv set to 1\nalternate\nalternate\nEnv set to 0\noriginal\noriginal\nThe following is the list of operations where rocBLAS may be used:\ntorch.addbmm\ntorch.addmm\ntorch.baddbmm\ntorch.bmm\ntorch.mm\ntorch.nn.GRUCell\ntorch.nn.LSTMCell\ntorch.nn.Linear\ntorch.sparse.addmm\nthe following torch._C._ConvBackend implementations:\nslowNd\nslowNd_transposed\nslowNd_dilated\nslowNd_dilated_transposed\nThe following is the list of operations where MIOpen may be used:\ntorch.nn.Conv[Transpose]Nd\nthe following torch._C._ConvBackend implementations:\nConvBackend::Miopen\nConvBackend::MiopenDepthwise\nConvBackend::MiopenTranspose",
  "url": "https://pytorch.org/docs/stable/notes/numerical_accuracy.html",
  "metadata": {
    "section": null,
    "issue_number": null,
    "labels": null,
    "answer_author": null
  }
}