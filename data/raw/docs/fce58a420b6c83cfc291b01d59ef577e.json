{
  "doc_id": "fce58a420b6c83cfc291b01d59ef577e",
  "source": "pytorch_docs",
  "title": "Distributed communication package - torch.distributed \u2014 PyTorch 2.9 documentation",
  "text": "\n## Distributed communication package - torch.distributed#\n\nCreated On: Jul 12, 2017 | Last Updated On: Sep 04, 2025\nNote\nPlease refer toPyTorch Distributed Overviewfor a brief introduction to all features related to distributed training.\n\n## Backends#\n\ntorch.distributedsupports four built-in backends, each with\ndifferent capabilities. The table below shows which functions are available\nfor use with a CPU or GPU for each backend. For NCCL, GPU refers to CUDA GPU\nwhile for XCCL to XPU GPU.\ntorch.distributed\nMPI supports CUDA only if the implementation used to build PyTorch supports it.\nBackend\ngloo\ngloo\nmpi\nmpi\nnccl\nnccl\nxccl\nxccl\nDevice\nCPU\nGPU\nCPU\nGPU\nCPU\nGPU\nCPU\nGPU\nsend\n\u2713\n\u2718\n\u2713\n?\n\u2718\n\u2713\n\u2718\n\u2713\nrecv\n\u2713\n\u2718\n\u2713\n?\n\u2718\n\u2713\n\u2718\n\u2713\nbroadcast\n\u2713\n\u2713\n\u2713\n?\n\u2718\n\u2713\n\u2718\n\u2713\nall_reduce\n\u2713\n\u2713\n\u2713\n?\n\u2718\n\u2713\n\u2718\n\u2713\nreduce\n\u2713\n\u2713\n\u2713\n?\n\u2718\n\u2713\n\u2718\n\u2713\nall_gather\n\u2713\n\u2713\n\u2713\n?\n\u2718\n\u2713\n\u2718\n\u2713\ngather\n\u2713\n\u2713\n\u2713\n?\n\u2718\n\u2713\n\u2718\n\u2713\nscatter\n\u2713\n\u2713\n\u2713\n?\n\u2718\n\u2713\n\u2718\n\u2713\nreduce_scatter\n\u2713\n\u2713\n\u2718\n\u2718\n\u2718\n\u2713\n\u2718\n\u2713\nall_to_all\n\u2713\n\u2713\n\u2713\n?\n\u2718\n\u2713\n\u2718\n\u2713\nbarrier\n\u2713\n\u2718\n\u2713\n?\n\u2718\n\u2713\n\u2718\n\u2713\n\n## Backends that come with PyTorch#\n\nPyTorch distributed package supports Linux (stable), MacOS (stable), and Windows (prototype).\nBy default for Linux, the Gloo and NCCL backends are built and included in PyTorch\ndistributed (NCCL only when building with CUDA). MPI is an optional backend that can only be\nincluded if you build PyTorch from source. (e.g. building PyTorch on a host that has MPI\ninstalled.)\nNote\nAs of PyTorch v1.8, Windows supports all collective communications backend but NCCL,\nIf theinit_methodargument ofinit_process_group()points to a file it must adhere\nto the following schema:\ninit_method\ninit_process_group()\nLocal file system,init_method=\"file:///d:/tmp/some_file\"\ninit_method=\"file:///d:/tmp/some_file\"\nShared file system,init_method=\"file://////{machine_name}/{share_folder_name}/some_file\"\ninit_method=\"file://////{machine_name}/{share_folder_name}/some_file\"\nSame as on Linux platform, you can enable TcpStore by setting environment variables,\nMASTER_ADDR and MASTER_PORT.\n\n## Which backend to use?#\n\nIn the past, we were often asked: \u201cwhich backend should I use?\u201d.\nRule of thumb\nUse the NCCL backend for distributed training with CUDAGPU.\nUse the XCCL backend for distributed training with XPUGPU.\nUse the Gloo backend for distributed training withCPU.\nGPU hosts with InfiniBand interconnect\nUse NCCL, since it\u2019s the only backend that currently supports\nInfiniBand and GPUDirect.\nGPU hosts with Ethernet interconnect\nUse NCCL, since it currently provides the best distributed GPU\ntraining performance, especially for multiprocess single-node or\nmulti-node distributed training. If you encounter any problem with\nNCCL, use Gloo as the fallback option. (Note that Gloo currently\nruns slower than NCCL for GPUs.)\nCPU hosts with InfiniBand interconnect\nIf your InfiniBand has enabled IP over IB, use Gloo, otherwise,\nuse MPI instead. We are planning on adding InfiniBand support for\nGloo in the upcoming releases.\nCPU hosts with Ethernet interconnect\nUse Gloo, unless you have specific reasons to use MPI.\n\n## Common environment variables#\n\nBy default, both the NCCL and Gloo backends will try to find the right network interface to use.\nIf the automatically detected interface is not correct, you can override it using the following\nenvironment variables (applicable to the respective backend):\nNCCL_SOCKET_IFNAME, for exampleexportNCCL_SOCKET_IFNAME=eth0\nexportNCCL_SOCKET_IFNAME=eth0\nGLOO_SOCKET_IFNAME, for exampleexportGLOO_SOCKET_IFNAME=eth0\nexportGLOO_SOCKET_IFNAME=eth0\nIf you\u2019re using the Gloo backend, you can specify multiple interfaces by separating\nthem by a comma, like this:exportGLOO_SOCKET_IFNAME=eth0,eth1,eth2,eth3.\nThe backend will dispatch operations in a round-robin fashion across these interfaces.\nIt is imperative that all processes specify the same number of interfaces in this variable.\nexportGLOO_SOCKET_IFNAME=eth0,eth1,eth2,eth3\nDebugging- in case of NCCL failure, you can setNCCL_DEBUG=INFOto print an explicit\nwarning message as well as basic NCCL initialization information.\nNCCL_DEBUG=INFO\nYou may also useNCCL_DEBUG_SUBSYSto get more details about a specific\naspect of NCCL. For example,NCCL_DEBUG_SUBSYS=COLLwould print logs of\ncollective calls, which may be helpful when debugging hangs, especially those\ncaused by collective type or message size mismatch. In case of topology\ndetection failure, it would be helpful to setNCCL_DEBUG_SUBSYS=GRAPHto inspect the detailed detection result and save as reference if further help\nfrom NCCL team is needed.\nNCCL_DEBUG_SUBSYS\nNCCL_DEBUG_SUBSYS=COLL\nNCCL_DEBUG_SUBSYS=GRAPH\nPerformance tuning- NCCL performs automatic tuning based on its topology detection to save users\u2019\ntuning effort. On some socket-based systems, users may still try tuningNCCL_SOCKET_NTHREADSandNCCL_NSOCKS_PERTHREADto increase socket\nnetwork bandwidth. These two environment variables have been pre-tuned by NCCL\nfor some cloud providers, such as AWS or GCP.\nNCCL_SOCKET_NTHREADS\nNCCL_NSOCKS_PERTHREAD\nFor a full list of NCCL environment variables, please refer toNVIDIA NCCL\u2019s official documentation\nYou can tune NCCL communicators even further usingtorch.distributed.ProcessGroupNCCL.NCCLConfigandtorch.distributed.ProcessGroupNCCL.Options. Learn more about them usinghelp(e.g.help(torch.distributed.ProcessGroupNCCL.NCCLConfig)) in the interpreter.\ntorch.distributed.ProcessGroupNCCL.NCCLConfig\ntorch.distributed.ProcessGroupNCCL.Options\nhelp\nhelp(torch.distributed.ProcessGroupNCCL.NCCLConfig)\n\n## Basics#\n\nThetorch.distributedpackage provides PyTorch support and communication primitives\nfor multiprocess parallelism across several computation nodes running on one or more\nmachines. The classtorch.nn.parallel.DistributedDataParallel()builds on this\nfunctionality to provide synchronous distributed training as a wrapper around any\nPyTorch model. This differs from the kinds of parallelism provided byMultiprocessing package - torch.multiprocessingandtorch.nn.DataParallel()in that it supports\nmultiple network-connected machines and in that the user must explicitly launch a separate\ncopy of the main training script for each process.\ntorch.distributed\ntorch.nn.parallel.DistributedDataParallel()\ntorch.nn.DataParallel()\nIn the single-machine synchronous case,torch.distributedor thetorch.nn.parallel.DistributedDataParallel()wrapper may still have advantages over other\napproaches to data-parallelism, includingtorch.nn.DataParallel():\ntorch.distributed\ntorch.nn.parallel.DistributedDataParallel()\ntorch.nn.DataParallel()\nEach process maintains its own optimizer and performs a complete optimization step with each\niteration. While this may appear redundant, since the gradients have already been gathered\ntogether and averaged across processes and are thus the same for every process, this means\nthat no parameter broadcast step is needed, reducing time spent transferring tensors between\nnodes.\nEach process contains an independent Python interpreter, eliminating the extra interpreter\noverhead and \u201cGIL-thrashing\u201d that comes from driving several execution threads, model\nreplicas, or GPUs from a single Python process. This is especially important for models that\nmake heavy use of the Python runtime, including models with recurrent layers or many small\ncomponents.\n\n## Initialization#\n\nThe package needs to be initialized using thetorch.distributed.init_process_group()ortorch.distributed.device_mesh.init_device_mesh()function before calling any other methods.\nBoth block until all processes have joined.\ntorch.distributed.init_process_group()\ntorch.distributed.device_mesh.init_device_mesh()\nWarning\nInitialization is not thread-safe. Process group creation should be performed from a single thread, to prevent\ninconsistent \u2018UUID\u2019 assignment across ranks, and to prevent races during initialization that can lead to hangs.\nReturnTrueif the distributed package is available.\nTrue\nOtherwise,torch.distributeddoes not expose any other APIs. Currently,torch.distributedis available on Linux, MacOS and Windows. SetUSE_DISTRIBUTED=1to enable it when building PyTorch from source.\nCurrently, the default value isUSE_DISTRIBUTED=1for Linux and Windows,USE_DISTRIBUTED=0for MacOS.\ntorch.distributed\ntorch.distributed\nUSE_DISTRIBUTED=1\nUSE_DISTRIBUTED=1\nUSE_DISTRIBUTED=0\nbool\nInitialize the default distributed process group.\nThis will also initialize the distributed package.\nSpecifystore,rank, andworld_sizeexplicitly.\nstore\nrank\nworld_size\nSpecifyinit_method(a URL string) which indicates where/how\nto discover peers. Optionally specifyrankandworld_size,\nor encode all required parameters in the URL and omit them.\ninit_method\nrank\nworld_size\nIf neither is specified,init_methodis assumed to be \u201cenv://\u201d.\ninit_method\nbackend(strorBackend,optional) \u2013 The backend to use. Depending on\nbuild-time configurations, valid values includempi,gloo,nccl,ucc,xcclor one that is registered by a third-party\nplugin.\nSince 2.6, ifbackendis not provided, c10d will use a backend\nregistered for the device type indicated by thedevice_idkwarg\n(if provided). The known default registrations today are:ncclforcuda,glooforcpu,xcclforxpu.\nIf neitherbackendnordevice_idis provided, c10d will\ndetect the accelerator on the run-time machine and use a backend\nregistered for that detected accelerator (orcpu).\nThis field can be given as a lowercase string (e.g.,\"gloo\"),\nwhich can also be accessed viaBackendattributes (e.g.,Backend.GLOO).\nIf using multiple processes per machine withncclbackend, each\nprocess must have exclusive access to every GPU it uses, as sharing\nGPUs between processes can result in deadlock or NCCL invalid usage.uccbackend is experimental.\nDefault backend for the device can be queried withget_default_backend_for_device().\nmpi\ngloo\nnccl\nucc\nxccl\nbackend\nnccl\ncuda\ngloo\ncpu\nxccl\nxpu\nbackend\ndevice_id\ncpu\n\"gloo\"\nBackend\nBackend.GLOO\nnccl\nucc\nget_default_backend_for_device()\ninit_method(str,optional) \u2013 URL specifying how to initialize the\nprocess group. Default is \u201cenv://\u201d if noinit_methodorstoreis specified.\nMutually exclusive withstore.\ninit_method\nstore\nstore\nworld_size(int,optional) \u2013 Number of processes participating in\nthe job. Required ifstoreis specified.\nstore\nrank(int,optional) \u2013 Rank of the current process (it should be a\nnumber between 0 andworld_size-1).\nRequired ifstoreis specified.\nworld_size\nstore\nstore(Store,optional) \u2013 Key/value store accessible to all workers, used\nto exchange connection/address information.\nMutually exclusive withinit_method.\ninit_method\ntimeout(timedelta,optional) \u2013 Timeout for operations executed against\nthe process group. Default value is 10 minutes for NCCL and 30 minutes for other backends.\nThis is the duration after which collectives will be aborted asynchronously and the process will crash.\nThis is done since CUDA execution is async and it is no longer safe to continue executing user code since\nfailed async NCCL operations might result in subsequent CUDA operations running on corrupted data.\nWhen TORCH_NCCL_BLOCKING_WAIT is set, the process will block and wait for this timeout.\ngroup_name(str,optional,deprecated) \u2013 Group name. This argument is ignored\npg_options(ProcessGroupOptions,optional) \u2013 process group options\nspecifying what additional options need to be passed in during\nthe construction of specific process groups. As of now, the only\noptions we support isProcessGroupNCCL.Optionsfor thencclbackend,is_high_priority_streamcan be specified so that\nthe nccl backend can pick up high priority cuda streams when\nthere\u2019re compute kernels waiting. For other available options to config nccl,\nSeehttps://docs.nvidia.com/deeplearning/nccl/user-guide/docs/api/types.html#ncclconfig-t\nProcessGroupNCCL.Options\nnccl\nis_high_priority_stream\ndevice_id(torch.device|int,optional) \u2013 a single, specific device\nthis process will work on, allowing for backend-specific\noptimizations.  Currently this has two effects, only under\nNCCL: the communicator is immediately formed (callingncclCommInit*immediately rather than the normal lazy\ncall) and sub-groups will usencclCommSplitwhen\npossible to avoid unnecessary overhead of group creation. If you\nwant to know NCCL initialization error early, you can also use this\nfield. If anintis provided, the API assumes that the accelerator\ntype at compile time will be used.\nncclCommInit*\nncclCommSplit\nNote\nTo enablebackend==Backend.MPI, PyTorch needs to be built from source\non a system that supports MPI.\nbackend==Backend.MPI\nNote\nSupport for multiple backends is experimental. Currently when no backend is\nspecified, bothglooandncclbackends will be created. Thegloobackend\nwill be used for collectives with CPU tensors and thencclbackend will be used\nfor collectives with CUDA tensors. A custom backend can be specified by passing in\na string with format \u201c<device_type>:<backend_name>,<device_type>:<backend_name>\u201d, e.g.\n\u201ccpu:gloo,cuda:custom_backend\u201d.\ngloo\nnccl\ngloo\nnccl\nInitializes aDeviceMeshbased ondevice_type,mesh_shape, andmesh_dim_namesparameters.\nThis creates a DeviceMesh with an n-dimensional array layout, wherenis the length ofmesh_shape.\nIfmesh_dim_namesis provided, each dimension is labeled asmesh_dim_names[i].\nNote\ninit_device_meshfollows SPMD programming model, meaning the same PyTorch Python program\nruns on all processes/ranks in the cluster. Ensuremesh_shape(the dimensions of the nD array\ndescribing device layout) is identical across all ranks. Inconsistentmesh_shapemay lead to hanging.\nNote\nIf no process group is found, init_device_mesh will initialize distributed process group/groups\nrequired for distributed communications behind the scene.\ndevice_type(str) \u2013 The device type of the mesh. Currently supports: \u201ccpu\u201d, \u201ccuda/cuda-like\u201d, \u201cxpu\u201d.\nPassing in a device type with a GPU index, such as \u201ccuda:0\u201d, is not allowed.\nmesh_shape(Tuple[int]) \u2013 A tuple defining the dimensions of the multi-dimensional array\ndescribing the layout of devices.\nmesh_dim_names(Tuple[str],optional) \u2013 A tuple of mesh dimension names to assign to each dimension\nof the multi-dimensional array describing the layout of devices. Its length must match the length\nofmesh_shape. Each string inmesh_dim_namesmust be unique.\nbackend_override(Dict[int|str,tuple[str,Options]|str|Options],optional) \u2013 Overrides for some or all of\nthe ProcessGroups that will be created for each mesh dimension. Each key can be either the index of a\ndimension or its name (if mesh_dim_names is provided). Each value can be a tuple containing the name\nof the backend and its options, or just one of these two components (in which case the other will be\nset to its default value).\nADeviceMeshobject representing the device layout.\nDeviceMesh\nDeviceMesh\nExample:\n\n```python\n>>> from torch.distributed.device_mesh import init_device_mesh\n>>>\n>>> mesh_1d = init_device_mesh(\"cuda\", mesh_shape=(8,))\n>>> mesh_2d = init_device_mesh(\"cuda\", mesh_shape=(2, 8), mesh_dim_names=(\"dp\", \"tp\"))\n\n```\n\nCheck if the default process group has been initialized.\nbool\nCheck if the MPI backend is available.\nbool\nCheck if the NCCL backend is available.\nbool\nCheck if the Gloo backend is available.\nbool\nCheck if the XCCL backend is available.\nbool\nCheck whether this process was launched withtorch.distributed.elastic(aka torchelastic).\ntorch.distributed.elastic\nThe existence ofTORCHELASTIC_RUN_IDenvironment\nvariable is used as a proxy to determine whether the current process\nwas launched with torchelastic. This is a reasonable proxy sinceTORCHELASTIC_RUN_IDmaps to the rendezvous id which is always a\nnon-null value indicating the job id for peer discovery purposes..\nTORCHELASTIC_RUN_ID\nTORCHELASTIC_RUN_ID\nbool\nReturn the default backend for the given device.\ndevice(Union[str,torch.device]) \u2013 The device to get the default backend for.\nThe default backend for the given device as a lower case string.\nstr\nCurrently three initialization methods are supported:\n\n## TCP initialization#\n\nThere are two ways to initialize using TCP, both requiring a network address\nreachable from all processes and a desiredworld_size. The first way\nrequires specifying an address that belongs to the rank 0 process. This\ninitialization method requires that all processes have manually specified ranks.\nworld_size\nNote that multicast address is not supported anymore in the latest distributed\npackage.group_nameis deprecated as well.\ngroup_name\n\n```python\nimport torch.distributed as dist\n\n# Use address of one of the machines\ndist.init_process_group(backend, init_method='tcp://10.1.1.20:23456',\n                        rank=args.rank, world_size=4)\n\n```\n\n\n## Shared file-system initialization#\n\nAnother initialization method makes use of a file system that is shared and\nvisible from all machines in a group, along with a desiredworld_size. The URL should start\nwithfile://and contain a path to a non-existent file (in an existing\ndirectory) on a shared file system. File-system initialization will automatically\ncreate that file if it doesn\u2019t exist, but will not delete the file. Therefore, it\nis your responsibility to make sure that the file is cleaned up before the nextinit_process_group()call on the same file path/name.\nworld_size\nfile://\ninit_process_group()\nNote that automatic rank assignment is not supported anymore in the latest\ndistributed package andgroup_nameis deprecated as well.\ngroup_name\nWarning\nThis method assumes that the file system supports locking usingfcntl- most\nlocal systems and NFS support it.\nfcntl\nWarning\nThis method will always create the file and try its best to clean up and remove\nthe file at the end of the program. In other words, each initialization with\nthe file init method will need a brand new empty file in order for the initialization\nto succeed. If the same file used by the previous initialization (which happens not\nto get cleaned up) is used again, this is unexpected behavior and can often cause\ndeadlocks and failures. Therefore, even though this method will try its best to clean up\nthe file, if the auto-delete happens to be unsuccessful, it is your responsibility\nto ensure that the file is removed at the end of the training to prevent the same\nfile to be reused again during the next time. This is especially important\nif you plan to callinit_process_group()multiple times on the same file name.\nIn other words, if the file is not removed/cleaned up and you callinit_process_group()again on that file, failures are expected.\nThe rule of thumb here is that, make sure that the file is non-existent or\nempty every timeinit_process_group()is called.\ninit_process_group()\ninit_process_group()\ninit_process_group()\n\n```python\nimport torch.distributed as dist\n\n# rank should always be specified\ndist.init_process_group(backend, init_method='file:///mnt/nfs/sharedfile',\n                        world_size=4, rank=args.rank)\n\n```\n\n\n## Environment variable initialization#\n\nThis method will read the configuration from environment variables, allowing\none to fully customize how the information is obtained. The variables to be set\nare:\nMASTER_PORT- required; has to be a free port on machine with rank 0\nMASTER_PORT\nMASTER_ADDR- required (except for rank 0); address of rank 0 node\nMASTER_ADDR\nWORLD_SIZE- required; can be set either here, or in a call to init function\nWORLD_SIZE\nRANK- required; can be set either here, or in a call to init function\nRANK\nThe machine with rank 0 will be used to set up all connections.\nThis is the default method, meaning thatinit_methoddoes not have to be specified (or\ncan beenv://).\ninit_method\nenv://\n\n## Improving initialization time#\n\nTORCH_GLOO_LAZY_INIT- establishes connections on demand rather than\nusing a full mesh which can greatly improve initialization time for non all2all\noperations.\nTORCH_GLOO_LAZY_INIT\n\n## Post-Initialization#\n\nOncetorch.distributed.init_process_group()was run, the following functions can be used. To\ncheck whether the process group has already been initialized usetorch.distributed.is_initialized().\ntorch.distributed.init_process_group()\ntorch.distributed.is_initialized()\nAn enum-like class for backends.\nAvailable backends: GLOO, NCCL, UCC, MPI, XCCL, and other registered backends.\nThe values of this class are lowercase strings, e.g.,\"gloo\". They can\nbe accessed as attributes, e.g.,Backend.NCCL.\n\"gloo\"\nBackend.NCCL\nThis class can be directly called to parse the string, e.g.,Backend(backend_str)will check ifbackend_stris valid, and\nreturn the parsed lowercase string if so. It also accepts uppercase strings,\ne.g.,Backend(\"GLOO\")returns\"gloo\".\nBackend(backend_str)\nbackend_str\nBackend(\"GLOO\")\n\"gloo\"\nNote\nThe entryBackend.UNDEFINEDis present but only used as\ninitial value of some fields. Users should neither use it directly\nnor assume its existence.\nBackend.UNDEFINED\nRegister a new backend with the given name and instantiating function.\nThis class method is used by 3rd partyProcessGroupextension to\nregister new backends.\nProcessGroup\nname(str) \u2013 Backend name of theProcessGroupextension. It\nshould match the one ininit_process_group().\nProcessGroup\ninit_process_group()\nfunc(function) \u2013 Function handler that instantiates the backend.\nThe function should be implemented in the backend\nextension and takes four arguments, includingstore,rank,world_size, andtimeout.\nstore\nrank\nworld_size\ntimeout\nextended_api(bool,optional) \u2013 Whether the backend supports extended argument structure.\nDefault:False. If set toTrue, the backend\nwill get an instance ofc10d::DistributedBackendOptions, and\na process group options object as defined by the backend implementation.\nFalse\nTrue\nc10d::DistributedBackendOptions\ndevice(strorlistofstr,optional) \u2013 device type this backend\nsupports, e.g. \u201ccpu\u201d, \u201ccuda\u201d, etc. IfNone,\nassuming both \u201ccpu\u201d and \u201ccuda\u201d\nNote\nThis support of 3rd party backend is experimental and subject to change.\nReturn the backend of the given process group.\ngroup(ProcessGroup,optional) \u2013 The process group to work on. The\ndefault is the general main process group. If another specific group\nis specified, the calling process must be part ofgroup.\ngroup\nThe backend of the given process group as a lower case string.\nBackend\nReturn the rank of the current process in the providedgroup, default otherwise.\ngroup\nRank is a unique identifier assigned to each process within a distributed\nprocess group. They are always consecutive integers ranging from 0 toworld_size.\nworld_size\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nThe rank of the process group\n-1, if not part of the group\nint\nReturn the number of processes in the current process group.\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nThe world size of the process group\n-1, if not part of the group\nint\n\n## Shutdown#\n\nIt is important to clean up resources on exit by callingdestroy_process_group().\ndestroy_process_group()\nThe simplest pattern to follow is to destroy every process group and backend by callingdestroy_process_group()with the default value of None for thegroupargument, at a\npoint in the training script where communications are no longer needed, usually near the\nend of main(). The call should be made once per trainer-process, not at the outer\nprocess-launcher level.\ndestroy_process_group()\ngroup\nifdestroy_process_group()is not called by all ranks in a pg within the timeout duration,\nespecially when there are multiple process-groups in the application e.g. for N-D parallelism,\nhangs on exit are possible. This is because the destructor for ProcessGroupNCCL calls ncclCommAbort,\nwhich must be called collectively, but the order of calling ProcessGroupNCCL\u2019s destructor if called\nby python\u2019s GC is not deterministic. Callingdestroy_process_group()helps by ensuring\nncclCommAbort is called in a consistent order across ranks, and avoids calling ncclCommAbort\nduring ProcessGroupNCCL\u2019s destructor.\ndestroy_process_group()\ndestroy_process_group()\n\n## Reinitialization#\n\ndestroy_process_groupcan also be used to destroy individual process groups. One use\ncase could be fault tolerant training, where a process group may be destroyed and then\na new one initialized during runtime. In this case, it\u2019s critical to synchronize the trainer\nprocesses using some means other than torch.distributed primitives _after_ calling destroy and\nbefore subsequently initializing. This behavior is currently unsupported/untested, due to\nthe difficulty of achieving this synchronization, and is considered a known issue. Please file\na github issue or RFC if this is a use case that\u2019s blocking you.\ndestroy_process_group\n\n## Groups#\n\nBy default collectives operate on the default group (also called the world) and\nrequire all processes to enter the distributed function call. However, some workloads can benefit\nfrom more fine-grained communication. This is where distributed groups come\ninto play.new_group()function can be\nused to create new groups, with arbitrary subsets of all processes. It returns\nan opaque group handle that can be given as agroupargument to all collectives\n(collectives are distributed functions to exchange information in certain well-known programming patterns).\nnew_group()\ngroup\nCreate a new distributed group.\nThis function requires that all processes in the main group (i.e. all\nprocesses that are part of the distributed job) enter this function, even\nif they are not going to be members of the group. Additionally, groups\nshould be created in the same order in all processes.\nWarning\nSafe concurrent usage:\nWhen using multiple process groups with theNCCLbackend, the user\nmust ensure a globally consistent execution order of collectives across\nranks.\nNCCL\nIf multiple threads within a process issue collectives, explicit\nsynchronization is necessary to ensure consistent ordering.\nWhen using async variants of torch.distributed communication APIs,\na work object is returned and the communication kernel is\nenqueued on a separate CUDA stream, allowing overlap of communication\nand computation. Once one or more async ops have been issued on one process\ngroup, they must be synchronized with other cuda streams by callingwork.wait()before using another process group.\nSeeUsing multiple NCCL communicators concurrently\n<https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/usage/communicators.html#using-multiple-nccl-communicators-concurrently>for more details.\nranks(list[int]) \u2013 List of ranks of group members. IfNone, will be\nset to all ranks. Default isNone.\nNone\nNone\ntimeout(timedelta,optional) \u2013 seeinit_process_groupfor details and default value.\nbackend(strorBackend,optional) \u2013 The backend to use. Depending on\nbuild-time configurations, valid values areglooandnccl.\nBy default uses the same backend as the global group. This field\nshould be given as a lowercase string (e.g.,\"gloo\"), which can\nalso be accessed viaBackendattributes (e.g.,Backend.GLOO). IfNoneis passed in, the backend\ncorresponding to the default process group will be used. Default isNone.\ngloo\nnccl\n\"gloo\"\nBackend\nBackend.GLOO\nNone\nNone\npg_options(ProcessGroupOptions,optional) \u2013 process group options\nspecifying what additional options need to be passed in during\nthe construction of specific process groups. i.e. for thencclbackend,is_high_priority_streamcan be specified so that\nprocess group can pick up high priority cuda streams. For other available options to config nccl,\nSeehttps://docs.nvidia.com/deeplearning/nccl/user-guide/docs/api/types.html#ncclconfig-tuse_local_synchronization(bool, optional): perform a group-local barrier at the end of the process group creation.\nThis is different in that non-member ranks don\u2019t need to call into API and don\u2019t\njoin the barrier.\nnccl\nis_high_priority_stream\ngroup_desc(str,optional) \u2013 a string to describe the process group.\ndevice_id(torch.device,optional) \u2013 a single, specific device\nto \u201cbind\u201d this process to,  Thenew_groupcall will try to initialize\na communication backend immediately for the device if this field is given.\nA handle of distributed group that can be given to collective calls or\nGroupMember.NON_GROUP_MEMBER if the rank is not part ofranks.\nranks\nN.B. use_local_synchronization doesn\u2019t work with MPI.\nN.B. While use_local_synchronization=True can be significantly faster with larger\nclusters and small process groups, care must be taken since it changes cluster behavior\nas non-member ranks don\u2019t join the group barrier().\nN.B. use_local_synchronization=True can lead to deadlocks when each rank creates\nmultiple overlapping process groups. To avoid that, make sure all ranks follow the\nsame global creation order.\nTranslate a global rank into a group rank.\nglobal_rankmust be part ofgroupotherwise this raises RuntimeError.\nglobal_rank\ngroup\ngroup(ProcessGroup) \u2013 ProcessGroup to find the relative rank.\nglobal_rank(int) \u2013 Global rank to query.\nGroup rank ofglobal_rankrelative togroup\nglobal_rank\ngroup\nint\nN.B. calling this function on the default process group returns identity\nTranslate a group rank into a global rank.\ngroup_rankmust be part ofgroupotherwise this raises RuntimeError.\ngroup_rank\ngroup(ProcessGroup) \u2013 ProcessGroup to find the global rank from.\ngroup_rank(int) \u2013 Group rank to query.\nGlobal rank ofgroup_rankrelative togroup\ngroup_rank\ngroup\nint\nN.B. calling this function on the default process group returns identity\nGet all ranks associated withgroup.\ngroup\ngroup(Optional[ProcessGroup]) \u2013 ProcessGroup to get all ranks from.\nIf None, the default process group will be used.\nList of global ranks ordered by group rank.\nlist[int]\n\n## DeviceMesh#\n\nDeviceMesh is a higher level abstraction that manages process groups (or NCCL communicators).\nIt allows user to easily create inter node and intra node process groups without worrying about\nhow to set up the ranks correctly for different sub process groups, and it helps manage those\ndistributed process group easily.init_device_mesh()function can be\nused to create new DeviceMesh, with a mesh shape describing the device topology.\ninit_device_mesh()\nDeviceMesh represents a mesh of devices, where layout of devices could be\nrepresented as a n-d dimension array, and each value of the n-d dimensional\narray is the global id of the default process group ranks.\nDeviceMesh could be used to setup the N dimensional device connections across the cluster,\nand manage the ProcessGroups for N dimensional parallelisms. Communications could happen on\neach dimension of the DeviceMesh separately. DeviceMesh respects the device that user selects\nalready (i.e. if user calltorch.cuda.set_devicebefore the DeviceMesh initialization),\nand will select/set the device for the current process if user does not set the device\nbeforehand. Note that manual device selection should happen BEFORE the DeviceMesh initialization.\nDeviceMesh can also be used as a context manager when using together with DTensor APIs.\nNote\nDeviceMesh follows SPMD programming model, which means the same PyTorch Python program\nis running on all processes/ranks in the cluster. Therefore, users need to make sure themesharray (which describes the layout of devices) should be identical across all ranks.\nInconsistentmeshwill lead to silent hang.\ndevice_type(str) \u2013 The device type of the mesh. Currently supports: \u201ccpu\u201d, \u201ccuda/cuda-like\u201d.\nmesh(ndarray) \u2013 A multi-dimensional array or an integer tensor describing the layout\nof devices, where the IDs are global IDs of the default process group.\nADeviceMeshobject representing the device layout.\nDeviceMesh\nDeviceMesh\nThe following program runs on each process/rank in an SPMD manner. In this example, we have 2\nhosts with 4 GPUs each.\nA reduction over the first dimension of mesh will reduce across\ncolumns (0, 4), .. and (3, 7), a reduction over the second dimension\nof mesh reduces across rows (0, 1, 2, 3) and (4, 5, 6, 7).\nExample:\n\n```python\n>>> from torch.distributed.device_mesh import DeviceMesh\n>>>\n>>> # Initialize device mesh as (2, 4) to represent the topology\n>>> # of cross-host(dim 0), and within-host (dim 1).\n>>> mesh = DeviceMesh(device_type=\"cuda\", mesh=[[0, 1, 2, 3],[4, 5, 6, 7]])\n\n```\n\nConstructs aDeviceMeshwithdevice_typefrom an\nexistingProcessGroupor a list of existingProcessGroup.\nDeviceMesh\ndevice_type\nProcessGroup\nProcessGroup\nThe constructed device mesh has number of dimensions equal to the\nnumber of groups passed. For example, if a single process group is passed in,\nthe resulted DeviceMesh is a 1D mesh. If a list of 2 process groups is passed in,\nthe resulted DeviceMesh is a 2D mesh.\nIf more than one group is passed, then themeshandmesh_dim_namesarguments\nare required. The order of the process groups passed in determines the topology of\nthe mesh. For example, the first process group will be the 0th dimension of the DeviceMesh.\nThemeshtensor passed in must have the same number of dimensions as the number of process\ngroups passed in, and the order of the dimensions in themeshtensor must match the order\nin the process groups passed in.\nmesh\nmesh_dim_names\ngroup(ProcessGrouporlist[ProcessGroup]) \u2013 the existing ProcessGroup\nor a list of existing ProcessGroups.\ndevice_type(str) \u2013 The device type of the mesh. Currently supports: \u201ccpu\u201d,\n\u201ccuda/cuda-like\u201d. Passing in a device type with a GPU index, such as \u201ccuda:0\u201d,\nis not allowed.\nmesh(torch.TensororArrayLike,optional) \u2013 A multi-dimensional array or an\ninteger tensor describing the layout of devices, where the IDs are global IDs\nof the default process group. Default is None.\nmesh_dim_names(tuple[str],optional) \u2013 A tuple of mesh dimension names to assign\nto each dimension of the multi-dimensional array describing the layout of devices.\nIts length must match the length ofmesh_shape. Each string inmesh_dim_namesmust be unique. Default is None.\nADeviceMeshobject representing the device layout.\nDeviceMesh\nDeviceMesh\nReturns a list of ProcessGroups for all mesh dimensions.\nA list ofProcessGroupobject.\nProcessGroup\nlist[torch.distributed.distributed_c10d.ProcessGroup]\nReturn the relative indices of this rank relative to all\ndimensions of the mesh. If this rank is not part of the mesh, return None.\nOptional[list[int]]\nReturns the single ProcessGroup specified by mesh_dim, or, if mesh_dim is not specified and the\nDeviceMesh is 1-dimensional, returns the only ProcessGroup in the mesh.\nmesh_dim(str/python:int,optional) \u2013 it can be the name of the mesh dimension or the index\nNone.(of the mesh dimension. Default is) \u2013\nAProcessGroupobject.\nProcessGroup\nProcessGroup\nReturns the local rank of the given mesh_dim of the DeviceMesh.\nmesh_dim(str/python:int,optional) \u2013 it can be the name of the mesh dimension or the index\nNone.(of the mesh dimension. Default is) \u2013\nAn integer denotes the local rank.\nint\nThe following program runs on each process/rank in an SPMD manner. In this example, we have 2\nhosts with 4 GPUs each.\nCalling mesh_2d.get_local_rank(mesh_dim=0) on rank 0, 1, 2, 3 would return 0.\nCalling mesh_2d.get_local_rank(mesh_dim=0) on rank 4, 5, 6, 7 would return 1.\nCalling mesh_2d.get_local_rank(mesh_dim=1) on rank 0, 4 would return 0.\nCalling mesh_2d.get_local_rank(mesh_dim=1) on rank 1, 5 would return 1.\nCalling mesh_2d.get_local_rank(mesh_dim=1) on rank 2, 6 would return 2.\nCalling mesh_2d.get_local_rank(mesh_dim=1) on rank 3, 7 would return 3.\nExample:\n\n```python\n>>> from torch.distributed.device_mesh import DeviceMesh\n>>>\n>>> # Initialize device mesh as (2, 4) to represent the topology\n>>> # of cross-host(dim 0), and within-host (dim 1).\n>>> mesh = DeviceMesh(device_type=\"cuda\", mesh=[[0, 1, 2, 3],[4, 5, 6, 7]])\n\n```\n\nReturns the current global rank.\nint\n\n## Point-to-point communication#\n\nSend a tensor synchronously.\nWarning\ntagis not supported with the NCCL backend.\ntag\ntensor(Tensor) \u2013 Tensor to send.\ndst(int) \u2013 Destination rank on global process group (regardless ofgroupargument).\nDestination rank should not be the same as the rank of the current process.\ngroup\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\ntag(int,optional) \u2013 Tag to match send with remote recv\ngroup_dst(int,optional) \u2013 Destination rank ongroup.  Invalid to specify bothdstandgroup_dst.\ngroup\ndst\ngroup_dst\nReceives a tensor synchronously.\nWarning\ntagis not supported with the NCCL backend.\ntag\ntensor(Tensor) \u2013 Tensor to fill with received data.\nsrc(int,optional) \u2013 Source rank on global process group (regardless ofgroupargument).\nWill receive from any process if unspecified.\ngroup\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\ntag(int,optional) \u2013 Tag to match recv with remote send\ngroup_src(int,optional) \u2013 Destination rank ongroup.  Invalid to specify bothsrcandgroup_src.\ngroup\nsrc\ngroup_src\nSender rank\n-1, if not part of the group\nint\nisend()andirecv()return distributed request objects when used. In general, the type of this object is unspecified\nas they should never be created manually, but they are guaranteed to support two methods:\nisend()\nirecv()\nis_completed()- returns True if the operation has finished\nis_completed()\nwait()- will block the process until the operation is finished.is_completed()is guaranteed to return True once it returns.\nwait()\nis_completed()\nSend a tensor asynchronously.\nWarning\nModifyingtensorbefore the request completes causes undefined\nbehavior.\ntensor\nWarning\ntagis not supported with the NCCL backend.\ntag\nUnlike send, which is blocking, isend allows src == dst rank, i.e. send to self.\ntensor(Tensor) \u2013 Tensor to send.\ndst(int) \u2013 Destination rank on global process group (regardless ofgroupargument)\ngroup\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\ntag(int,optional) \u2013 Tag to match send with remote recv\ngroup_dst(int,optional) \u2013 Destination rank ongroup.  Invalid to specify bothdstandgroup_dst\ngroup\ndst\ngroup_dst\nA distributed request object.\nNone, if not part of the group\nOptional[Work]\nReceives a tensor asynchronously.\nWarning\ntagis not supported with the NCCL backend.\ntag\nUnlike recv, which is blocking, irecv allows src == dst rank, i.e. recv from self.\ntensor(Tensor) \u2013 Tensor to fill with received data.\nsrc(int,optional) \u2013 Source rank on global process group (regardless ofgroupargument).\nWill receive from any process if unspecified.\ngroup\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\ntag(int,optional) \u2013 Tag to match recv with remote send\ngroup_src(int,optional) \u2013 Destination rank ongroup.  Invalid to specify bothsrcandgroup_src.\ngroup\nsrc\ngroup_src\nA distributed request object.\nNone, if not part of the group\nOptional[Work]\nSends picklable objects inobject_listsynchronously.\nobject_list\nSimilar tosend(), but Python objects can be passed in.\nNote that all objects inobject_listmust be picklable in order to be\nsent.\nsend()\nobject_list\nobject_list(List[Any]) \u2013 List of input objects to sent.\nEach object must be picklable. Receiver must provide lists of equal sizes.\ndst(int) \u2013 Destination rank to sendobject_listto.\nDestination rank is based on global process group (regardless ofgroupargument)\nobject_list\ngroup\ngroup(Optional[ProcessGroup]) \u2013 (ProcessGroup, optional): The process group to work on. If None,\nthe default process group will be used. Default isNone.\nNone\ndevice(torch.device, optional) \u2013 If not None, the objects are\nserialized and converted to tensors which are moved to thedevicebefore sending. Default isNone.\ntorch.device\ndevice\nNone\ngroup_dst(int,optional) \u2013 Destination rank ongroup.\nMust specify one ofdstandgroup_dstbut not both\ngroup\ndst\ngroup_dst\nuse_batch(bool,optional) \u2013 If True, use batch p2p operations instead of\nregular send operations. This avoids initializing 2-rank communicators and\nuses existing entire group communicators. See batch_isend_irecv for usage and\nassumptions. Default isFalse.\nFalse\nNone.\nNone\nNote\nFor NCCL-based process groups, internal tensor representations\nof objects must be moved to the GPU device before communication takes\nplace. In this case, the device used is given bytorch.cuda.current_device()and it is the user\u2019s responsibility to\nensure that this is set so that each rank has an individual GPU, viatorch.cuda.set_device().\ntorch.cuda.current_device()\ntorch.cuda.set_device()\nWarning\nObject collectives have a number of serious performance and scalability\nlimitations.  SeeObject collectivesfor details.\nWarning\nsend_object_list()usespicklemodule implicitly, which\nis known to be insecure. It is possible to construct malicious pickle\ndata which will execute arbitrary code during unpickling. Only call this\nfunction with data you trust.\nsend_object_list()\npickle\nWarning\nCallingsend_object_list()with GPU tensors is not well supported\nand inefficient as it incurs GPU -> CPU transfer since tensors would be\npickled. Please consider usingsend()instead.\nsend_object_list()\nsend()\n\n```python\n>>> # Note: Process group initialization omitted on each rank.\n>>> import torch.distributed as dist\n>>> # Assumes backend is not NCCL\n>>> device = torch.device(\"cpu\")\n>>> if dist.get_rank() == 0:\n>>>     # Assumes world_size of 2.\n>>>     objects = [\"foo\", 12, {1: 2}] # any picklable object\n>>>     dist.send_object_list(objects, dst=1, device=device)\n>>> else:\n>>>     objects = [None, None, None]\n>>>     dist.recv_object_list(objects, src=0, device=device)\n>>> objects\n['foo', 12, {1: 2}]\n\n```\n\nReceives picklable objects inobject_listsynchronously.\nobject_list\nSimilar torecv(), but can receive Python objects.\nrecv()\nobject_list(List[Any]) \u2013 List of objects to receive into.\nMust provide a list of sizes equal to the size of the list being sent.\nsrc(int,optional) \u2013 Source rank from which to recvobject_list.\nSource rank is based on global process group (regardless ofgroupargument)\nWill receive from any rank if set to None. Default isNone.\nobject_list\ngroup\nNone\ngroup(Optional[ProcessGroup]) \u2013 (ProcessGroup, optional): The process group to work on. If None,\nthe default process group will be used. Default isNone.\nNone\ndevice(torch.device, optional) \u2013 If not None, receives on this device.\nDefault isNone.\ntorch.device\nNone\ngroup_src(int,optional) \u2013 Destination rank ongroup.  Invalid to specify bothsrcandgroup_src.\ngroup\nsrc\ngroup_src\nuse_batch(bool,optional) \u2013 If True, use batch p2p operations instead of\nregular send operations. This avoids initializing 2-rank communicators and\nuses existing entire group communicators. See batch_isend_irecv for usage and\nassumptions. Default isFalse.\nFalse\nSender rank. -1 if rank is not part of the group. If rank is part of the group,object_listwill contain the sent objects fromsrcrank.\nobject_list\nsrc\nNote\nFor NCCL-based process groups, internal tensor representations\nof objects must be moved to the GPU device before communication takes\nplace. In this case, the device used is given bytorch.cuda.current_device()and it is the user\u2019s responsibility to\nensure that this is set so that each rank has an individual GPU, viatorch.cuda.set_device().\ntorch.cuda.current_device()\ntorch.cuda.set_device()\nWarning\nObject collectives have a number of serious performance and scalability\nlimitations.  SeeObject collectivesfor details.\nWarning\nrecv_object_list()usespicklemodule implicitly, which\nis known to be insecure. It is possible to construct malicious pickle\ndata which will execute arbitrary code during unpickling. Only call this\nfunction with data you trust.\nrecv_object_list()\npickle\nWarning\nCallingrecv_object_list()with GPU tensors is not well supported\nand inefficient as it incurs GPU -> CPU transfer since tensors would be\npickled. Please consider usingrecv()instead.\nrecv_object_list()\nrecv()\n\n```python\n>>> # Note: Process group initialization omitted on each rank.\n>>> import torch.distributed as dist\n>>> # Assumes backend is not NCCL\n>>> device = torch.device(\"cpu\")\n>>> if dist.get_rank() == 0:\n>>>     # Assumes world_size of 2.\n>>>     objects = [\"foo\", 12, {1: 2}] # any picklable object\n>>>     dist.send_object_list(objects, dst=1, device=device)\n>>> else:\n>>>     objects = [None, None, None]\n>>>     dist.recv_object_list(objects, src=0, device=device)\n>>> objects\n['foo', 12, {1: 2}]\n\n```\n\nSend or Receive a batch of tensors asynchronously and return a list of requests.\nProcess each of the operations inp2p_op_listand return the corresponding\nrequests. NCCL, Gloo, and UCC backend are currently supported.\np2p_op_list\np2p_op_list(list[torch.distributed.distributed_c10d.P2POp]) \u2013 A list of point-to-point operations(type of each operator istorch.distributed.P2POp). The order of the isend/irecv in the list\nmatters and it needs to match with corresponding isend/irecv on the\nremote end.\ntorch.distributed.P2POp\nA list of distributed request objects returned by calling the corresponding\nop in the op_list.\nlist[torch.distributed.distributed_c10d.Work]\nExamples\n\n```python\n>>> send_tensor = torch.arange(2, dtype=torch.float32) + 2 * rank\n>>> recv_tensor = torch.randn(2, dtype=torch.float32)\n>>> send_op = dist.P2POp(dist.isend, send_tensor, (rank + 1) % world_size)\n>>> recv_op = dist.P2POp(\n...     dist.irecv, recv_tensor, (rank - 1 + world_size) % world_size\n... )\n>>> reqs = batch_isend_irecv([send_op, recv_op])\n>>> for req in reqs:\n>>>     req.wait()\n>>> recv_tensor\ntensor([2, 3])     # Rank 0\ntensor([0, 1])     # Rank 1\n\n```\n\nNote\nNote that when this API is used with the NCCL PG backend, users must set\nthe current GPU device withtorch.cuda.set_device, otherwise it will\nlead to unexpected hang issues.\nIn addition, if this API is the first collective call in thegrouppassed todist.P2POp, all ranks of thegroupmust participate in\nthis API call; otherwise, the behavior is undefined. If this API call is\nnot the first collective call in thegroup, batched P2P operations\ninvolving only a subset of ranks of thegroupare allowed.\ngroup\ndist.P2POp\ngroup\ngroup\ngroup\nA class to build point-to-point operations forbatch_isend_irecv.\nbatch_isend_irecv\nThis class builds the type of P2P operation, communication buffer, peer rank,\nProcess Group, and tag. Instances of this class will be passed tobatch_isend_irecvfor point-to-point communications.\nbatch_isend_irecv\nop(Callable) \u2013 A function to send data to or receive data from a peer process.\nThe type ofopis eithertorch.distributed.isendortorch.distributed.irecv.\nop\ntorch.distributed.isend\ntorch.distributed.irecv\ntensor(Tensor) \u2013 Tensor to send or receive.\npeer(int,optional) \u2013 Destination or source rank.\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\ntag(int,optional) \u2013 Tag to match send with recv.\ngroup_peer(int,optional) \u2013 Destination or source rank.\n\n## Synchronous and asynchronous collective operations#\n\nEvery collective operation function supports the following two kinds of operations,\ndepending on the setting of theasync_opflag passed into the collective:\nasync_op\nSynchronous operation- the default mode, whenasync_opis set toFalse.\nWhen the function returns, it is guaranteed that\nthe collective operation is performed. In the case of CUDA operations, it is not guaranteed\nthat the CUDA operation is completed, since CUDA operations are asynchronous. For CPU collectives, any\nfurther function calls utilizing the output of the collective call will behave as expected. For CUDA collectives,\nfunction calls utilizing the output on the same CUDA stream will behave as expected. Users must take care of\nsynchronization under the scenario of running under different streams. For details on CUDA semantics such as stream\nsynchronization, seeCUDA Semantics.\nSee the below script to see examples of differences in these semantics for CPU and CUDA operations.\nasync_op\nFalse\nAsynchronous operation- whenasync_opis set to True. The collective operation function\nreturns a distributed request object. In general, you don\u2019t need to create it manually and it\nis guaranteed to support two methods:\nasync_op\nis_completed()- in the case of CPU collectives, returnsTrueif completed. In the case of CUDA operations,\nreturnsTrueif the operation has been successfully enqueued onto a CUDA stream and the output can be utilized on the\ndefault stream without further synchronization.\nis_completed()\nTrue\nTrue\nwait()- in the case of CPU collectives, will block the process until the operation is completed. In the case\nof CUDA collectives, will block the currently active CUDA stream until the operation is completed (but will not block the CPU).\nwait()\nget_future()- returnstorch._C.Futureobject. Supported for NCCL, also supported for most operations on GLOO\nand MPI, except for peer to peer operations.\nNote: as we continue adopting Futures and merging APIs,get_future()call might become redundant.\nget_future()\ntorch._C.Future\nget_future()\nExample\nThe following code can serve as a reference regarding semantics for CUDA operations when using distributed collectives.\nIt shows the explicit need to synchronize when using collective outputs on different CUDA streams:\n\n```python\n# Code runs on each rank.\ndist.init_process_group(\"nccl\", rank=rank, world_size=2)\noutput = torch.tensor([rank]).cuda(rank)\ns = torch.cuda.Stream()\nhandle = dist.all_reduce(output, async_op=True)\n# Wait ensures the operation is enqueued, but not necessarily complete.\nhandle.wait()\n# Using result on non-default stream.\nwith torch.cuda.stream(s):\n    s.wait_stream(torch.cuda.default_stream())\n    output.add_(100)\nif rank == 0:\n    # if the explicit call to wait_stream was omitted, the output below will be\n    # non-deterministically 1 or 101, depending on whether the allreduce overwrote\n    # the value after the add completed.\n    print(output)\n\n```\n\n\n## Collective functions#\n\nBroadcasts the tensor to the whole group.\ntensormust have the same number of elements in all processes\nparticipating in the collective.\ntensor\ntensor(Tensor) \u2013 Data to be sent ifsrcis the rank of current\nprocess, and tensor to be used to save received data otherwise.\nsrc\nsrc(int) \u2013 Source rank on global process group (regardless ofgroupargument).\ngroup\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nasync_op(bool,optional) \u2013 Whether this op should be an async op\ngroup_src(int) \u2013 Source rank ongroup.  Must specify one ofgroup_srcandsrcbut not both.\ngroup\ngroup_src\nsrc\nAsync work handle, if async_op is set to True.\nNone, if not async_op or if not part of the group\nBroadcasts picklable objects inobject_listto the whole group.\nobject_list\nSimilar tobroadcast(), but Python objects can be passed in.\nNote that all objects inobject_listmust be picklable in order to be\nbroadcasted.\nbroadcast()\nobject_list\nobject_list(List[Any]) \u2013 List of input objects to broadcast.\nEach object must be picklable. Only objects on thesrcrank will\nbe broadcast, but each rank must provide lists of equal sizes.\nsrc\nsrc(int) \u2013 Source rank from which to broadcastobject_list.\nSource rank is based on global process group (regardless ofgroupargument)\nobject_list\ngroup\ngroup(Optional[ProcessGroup]) \u2013 (ProcessGroup, optional): The process group to work on. If None,\nthe default process group will be used. Default isNone.\nNone\ndevice(torch.device, optional) \u2013 If not None, the objects are\nserialized and converted to tensors which are moved to thedevicebefore broadcasting. Default isNone.\ntorch.device\ndevice\nNone\ngroup_src(int) \u2013 Source rank ongroup.  Must not specify one ofgroup_srcandsrcbut not both.\ngroup\ngroup_src\nsrc\nNone. If rank is part of the group,object_listwill contain the\nbroadcasted objects fromsrcrank.\nNone\nobject_list\nsrc\nNote\nFor NCCL-based process groups, internal tensor representations\nof objects must be moved to the GPU device before communication takes\nplace. In this case, the device used is given bytorch.cuda.current_device()and it is the user\u2019s responsibility to\nensure that this is set so that each rank has an individual GPU, viatorch.cuda.set_device().\ntorch.cuda.current_device()\ntorch.cuda.set_device()\nNote\nNote that this API differs slightly from thebroadcast()collective since it does not provide anasync_ophandle and thus\nwill be a blocking call.\nbroadcast()\nasync_op\nWarning\nObject collectives have a number of serious performance and scalability\nlimitations.  SeeObject collectivesfor details.\nWarning\nbroadcast_object_list()usespicklemodule implicitly, which\nis known to be insecure. It is possible to construct malicious pickle\ndata which will execute arbitrary code during unpickling. Only call this\nfunction with data you trust.\nbroadcast_object_list()\npickle\nWarning\nCallingbroadcast_object_list()with GPU tensors is not well supported\nand inefficient as it incurs GPU -> CPU transfer since tensors would be\npickled. Please consider usingbroadcast()instead.\nbroadcast_object_list()\nbroadcast()\n\n```python\n>>> # Note: Process group initialization omitted on each rank.\n>>> import torch.distributed as dist\n>>> if dist.get_rank() == 0:\n>>>     # Assumes world_size of 3.\n>>>     objects = [\"foo\", 12, {1: 2}] # any picklable object\n>>> else:\n>>>     objects = [None, None, None]\n>>> # Assumes backend is not NCCL\n>>> device = torch.device(\"cpu\")\n>>> dist.broadcast_object_list(objects, src=0, device=device)\n>>> objects\n['foo', 12, {1: 2}]\n\n```\n\nReduces the tensor data across all machines in a way that all get the final result.\nAfter the calltensoris going to be bitwise identical in all processes.\ntensor\nComplex tensors are supported.\ntensor(Tensor) \u2013 Input and output of the collective. The function\noperates in-place.\nop(optional) \u2013 One of the values fromtorch.distributed.ReduceOpenum.  Specifies an operation used for element-wise reductions.\ntorch.distributed.ReduceOp\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nasync_op(bool,optional) \u2013 Whether this op should be an async op\nAsync work handle, if async_op is set to True.\nNone, if not async_op or if not part of the group\nExamples\n\n```python\n>>> # All tensors below are of torch.int64 type.\n>>> # We have 2 process groups, 2 ranks.\n>>> device = torch.device(f\"cuda:{rank}\")\n>>> tensor = torch.arange(2, dtype=torch.int64, device=device) + 1 + 2 * rank\n>>> tensor\ntensor([1, 2], device='cuda:0') # Rank 0\ntensor([3, 4], device='cuda:1') # Rank 1\n>>> dist.all_reduce(tensor, op=ReduceOp.SUM)\n>>> tensor\ntensor([4, 6], device='cuda:0') # Rank 0\ntensor([4, 6], device='cuda:1') # Rank 1\n\n```\n\n\n```python\n>>> # All tensors below are of torch.cfloat type.\n>>> # We have 2 process groups, 2 ranks.\n>>> tensor = torch.tensor(\n...     [1 + 1j, 2 + 2j], dtype=torch.cfloat, device=device\n... ) + 2 * rank * (1 + 1j)\n>>> tensor\ntensor([1.+1.j, 2.+2.j], device='cuda:0') # Rank 0\ntensor([3.+3.j, 4.+4.j], device='cuda:1') # Rank 1\n>>> dist.all_reduce(tensor, op=ReduceOp.SUM)\n>>> tensor\ntensor([4.+4.j, 6.+6.j], device='cuda:0') # Rank 0\ntensor([4.+4.j, 6.+6.j], device='cuda:1') # Rank 1\n\n```\n\nReduces the tensor data across all machines.\nOnly the process with rankdstis going to receive the final result.\ndst\ntensor(Tensor) \u2013 Input and output of the collective. The function\noperates in-place.\ndst(int) \u2013 Destination rank on global process group (regardless ofgroupargument)\ngroup\nop(optional) \u2013 One of the values fromtorch.distributed.ReduceOpenum.  Specifies an operation used for element-wise reductions.\ntorch.distributed.ReduceOp\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nasync_op(bool,optional) \u2013 Whether this op should be an async op\ngroup_dst(int) \u2013 Destination rank ongroup.  Must specify one ofgroup_dstanddstbut not both.\ngroup\ngroup_dst\ndst\nAsync work handle, if async_op is set to True.\nNone, if not async_op or if not part of the group\nGathers tensors from the whole group in a list.\nComplex and uneven sized tensors are supported.\ntensor_list(list[Tensor]) \u2013 Output list. It should contain\ncorrectly-sized tensors to be used for output of the collective.\nUneven sized tensors are supported.\ntensor(Tensor) \u2013 Tensor to be broadcast from current process.\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nasync_op(bool,optional) \u2013 Whether this op should be an async op\nAsync work handle, if async_op is set to True.\nNone, if not async_op or if not part of the group\nExamples\n\n```python\n>>> # All tensors below are of torch.int64 dtype.\n>>> # We have 2 process groups, 2 ranks.\n>>> device = torch.device(f\"cuda:{rank}\")\n>>> tensor_list = [\n...     torch.zeros(2, dtype=torch.int64, device=device) for _ in range(2)\n... ]\n>>> tensor_list\n[tensor([0, 0], device='cuda:0'), tensor([0, 0], device='cuda:0')] # Rank 0\n[tensor([0, 0], device='cuda:1'), tensor([0, 0], device='cuda:1')] # Rank 1\n>>> tensor = torch.arange(2, dtype=torch.int64, device=device) + 1 + 2 * rank\n>>> tensor\ntensor([1, 2], device='cuda:0') # Rank 0\ntensor([3, 4], device='cuda:1') # Rank 1\n>>> dist.all_gather(tensor_list, tensor)\n>>> tensor_list\n[tensor([1, 2], device='cuda:0'), tensor([3, 4], device='cuda:0')] # Rank 0\n[tensor([1, 2], device='cuda:1'), tensor([3, 4], device='cuda:1')] # Rank 1\n\n```\n\n\n```python\n>>> # All tensors below are of torch.cfloat dtype.\n>>> # We have 2 process groups, 2 ranks.\n>>> tensor_list = [\n...     torch.zeros(2, dtype=torch.cfloat, device=device) for _ in range(2)\n... ]\n>>> tensor_list\n[tensor([0.+0.j, 0.+0.j], device='cuda:0'), tensor([0.+0.j, 0.+0.j], device='cuda:0')] # Rank 0\n[tensor([0.+0.j, 0.+0.j], device='cuda:1'), tensor([0.+0.j, 0.+0.j], device='cuda:1')] # Rank 1\n>>> tensor = torch.tensor(\n...     [1 + 1j, 2 + 2j], dtype=torch.cfloat, device=device\n... ) + 2 * rank * (1 + 1j)\n>>> tensor\ntensor([1.+1.j, 2.+2.j], device='cuda:0') # Rank 0\ntensor([3.+3.j, 4.+4.j], device='cuda:1') # Rank 1\n>>> dist.all_gather(tensor_list, tensor)\n>>> tensor_list\n[tensor([1.+1.j, 2.+2.j], device='cuda:0'), tensor([3.+3.j, 4.+4.j], device='cuda:0')] # Rank 0\n[tensor([1.+1.j, 2.+2.j], device='cuda:1'), tensor([3.+3.j, 4.+4.j], device='cuda:1')] # Rank 1\n\n```\n\nGather tensors from all ranks and put them in a single output tensor.\nThis function requires all tensors to be the same size on each process.\noutput_tensor(Tensor) \u2013 Output tensor to accommodate tensor elements\nfrom all ranks. It must be correctly sized to have one of the\nfollowing forms:\n(i) a concatenation of all the input tensors along the primary\ndimension; for definition of \u201cconcatenation\u201d, seetorch.cat();\n(ii) a stack of all the input tensors along the primary dimension;\nfor definition of \u201cstack\u201d, seetorch.stack().\nExamples below may better explain the supported output forms.\ntorch.cat()\ntorch.stack()\ninput_tensor(Tensor) \u2013 Tensor to be gathered from current rank.\nDifferent from theall_gatherAPI, the input tensors in this\nAPI must have the same size across all ranks.\nall_gather\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nasync_op(bool,optional) \u2013 Whether this op should be an async op\nAsync work handle, if async_op is set to True.\nNone, if not async_op or if not part of the group\nExamples\n\n```python\n>>> # All tensors below are of torch.int64 dtype and on CUDA devices.\n>>> # We have two ranks.\n>>> device = torch.device(f\"cuda:{rank}\")\n>>> tensor_in = torch.arange(2, dtype=torch.int64, device=device) + 1 + 2 * rank\n>>> tensor_in\ntensor([1, 2], device='cuda:0') # Rank 0\ntensor([3, 4], device='cuda:1') # Rank 1\n>>> # Output in concatenation form\n>>> tensor_out = torch.zeros(world_size * 2, dtype=torch.int64, device=device)\n>>> dist.all_gather_into_tensor(tensor_out, tensor_in)\n>>> tensor_out\ntensor([1, 2, 3, 4], device='cuda:0') # Rank 0\ntensor([1, 2, 3, 4], device='cuda:1') # Rank 1\n>>> # Output in stack form\n>>> tensor_out2 = torch.zeros(world_size, 2, dtype=torch.int64, device=device)\n>>> dist.all_gather_into_tensor(tensor_out2, tensor_in)\n>>> tensor_out2\ntensor([[1, 2],\n        [3, 4]], device='cuda:0') # Rank 0\ntensor([[1, 2],\n        [3, 4]], device='cuda:1') # Rank 1\n\n```\n\nGathers picklable objects from the whole group into a list.\nSimilar toall_gather(), but Python objects can be passed in.\nNote that the object must be picklable in order to be gathered.\nall_gather()\nobject_list(list[Any]) \u2013 Output list. It should be correctly sized as the\nsize of the group for this collective and will contain the output.\nobj(Any) \u2013 Pickable Python object to be broadcast from current process.\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used. Default isNone.\nNone\nNone. If the calling rank is part of this group, the output of the\ncollective will be populated into the inputobject_list. If the\ncalling rank is not part of the group, the passed inobject_listwill\nbe unmodified.\nobject_list\nobject_list\nNote\nNote that this API differs slightly from theall_gather()collective since it does not provide anasync_ophandle and thus\nwill be a blocking call.\nall_gather()\nasync_op\nNote\nFor NCCL-based processed groups, internal tensor representations\nof objects must be moved to the GPU device before communication takes\nplace. In this case, the device used is given bytorch.cuda.current_device()and it is the user\u2019s responsibility to\nensure that this is set so that each rank has an individual GPU, viatorch.cuda.set_device().\ntorch.cuda.current_device()\ntorch.cuda.set_device()\nWarning\nObject collectives have a number of serious performance and scalability\nlimitations.  SeeObject collectivesfor details.\nWarning\nall_gather_object()usespicklemodule implicitly, which is\nknown to be insecure. It is possible to construct malicious pickle data\nwhich will execute arbitrary code during unpickling. Only call this\nfunction with data you trust.\nall_gather_object()\npickle\nWarning\nCallingall_gather_object()with GPU tensors is not well supported\nand inefficient as it incurs GPU -> CPU transfer since tensors would be\npickled. Please consider usingall_gather()instead.\nall_gather_object()\nall_gather()\n\n```python\n>>> # Note: Process group initialization omitted on each rank.\n>>> import torch.distributed as dist\n>>> # Assumes world_size of 3.\n>>> gather_objects = [\"foo\", 12, {1: 2}] # any picklable object\n>>> output = [None for _ in gather_objects]\n>>> dist.all_gather_object(output, gather_objects[dist.get_rank()])\n>>> output\n['foo', 12, {1: 2}]\n\n```\n\nGathers a list of tensors in a single process.\nThis function requires all tensors to be the same size on each process.\ntensor(Tensor) \u2013 Input tensor.\ngather_list(list[Tensor],optional) \u2013 List of appropriately,\nsame-sized tensors to use for gathered data\n(default is None, must be specified on the destination rank)\ndst(int,optional) \u2013 Destination rank on global process group (regardless ofgroupargument).\n(If bothdstandgroup_dstare None, default is global rank 0)\ngroup\ndst\ngroup_dst\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nasync_op(bool,optional) \u2013 Whether this op should be an async op\ngroup_dst(int,optional) \u2013 Destination rank ongroup.  Invalid to specify bothdstandgroup_dst\ngroup\ndst\ngroup_dst\nAsync work handle, if async_op is set to True.\nNone, if not async_op or if not part of the group\nNote\nNote that all Tensors in gather_list must have the same size.\n\n```python\n>>> # We have 2 process groups, 2 ranks.\n>>> tensor_size = 2\n>>> device = torch.device(f'cuda:{rank}')\n>>> tensor = torch.ones(tensor_size, device=device) + rank\n>>> if dist.get_rank() == 0:\n>>>     gather_list = [torch.zeros_like(tensor, device=device) for i in range(2)]\n>>> else:\n>>>     gather_list = None\n>>> dist.gather(tensor, gather_list, dst=0)\n>>> # Rank 0 gets gathered data.\n>>> gather_list\n[tensor([1., 1.], device='cuda:0'), tensor([2., 2.], device='cuda:0')] # Rank 0\nNone                                                                   # Rank 1\n\n```\n\nGathers picklable objects from the whole group in a single process.\nSimilar togather(), but Python objects can be passed in. Note that the\nobject must be picklable in order to be gathered.\ngather()\nobj(Any) \u2013 Input object. Must be picklable.\nobject_gather_list(list[Any]) \u2013 Output list. On thedstrank, it\nshould be correctly sized as the size of the group for this\ncollective and will contain the output. Must beNoneon non-dst\nranks. (default isNone)\ndst\nNone\nNone\ndst(int,optional) \u2013 Destination rank on global process group (regardless ofgroupargument).\n(If bothdstandgroup_dstare None, default is global rank 0)\ngroup\ndst\ngroup_dst\ngroup(Optional[ProcessGroup]) \u2013 (ProcessGroup, optional): The process group to work on. If None,\nthe default process group will be used. Default isNone.\nNone\ngroup_dst(int,optional) \u2013 Destination rank ongroup.  Invalid to specify bothdstandgroup_dst\ngroup\ndst\ngroup_dst\nNone. On thedstrank,object_gather_listwill contain the\noutput of the collective.\ndst\nobject_gather_list\nNote\nNote that this API differs slightly from the gather collective\nsince it does not provide an async_op handle and thus will be a blocking\ncall.\nNote\nFor NCCL-based processed groups, internal tensor representations\nof objects must be moved to the GPU device before communication takes\nplace. In this case, the device used is given bytorch.cuda.current_device()and it is the user\u2019s responsibility to\nensure that this is set so that each rank has an individual GPU, viatorch.cuda.set_device().\ntorch.cuda.current_device()\ntorch.cuda.set_device()\nWarning\nObject collectives have a number of serious performance and scalability\nlimitations.  SeeObject collectivesfor details.\nWarning\ngather_object()usespicklemodule implicitly, which is\nknown to be insecure. It is possible to construct malicious pickle data\nwhich will execute arbitrary code during unpickling. Only call this\nfunction with data you trust.\ngather_object()\npickle\nWarning\nCallinggather_object()with GPU tensors is not well supported\nand inefficient as it incurs GPU -> CPU transfer since tensors would be\npickled. Please consider usinggather()instead.\ngather_object()\ngather()\n\n```python\n>>> # Note: Process group initialization omitted on each rank.\n>>> import torch.distributed as dist\n>>> # Assumes world_size of 3.\n>>> gather_objects = [\"foo\", 12, {1: 2}] # any picklable object\n>>> output = [None for _ in gather_objects]\n>>> dist.gather_object(\n...     gather_objects[dist.get_rank()],\n...     output if dist.get_rank() == 0 else None,\n...     dst=0\n... )\n>>> # On rank 0\n>>> output\n['foo', 12, {1: 2}]\n\n```\n\nScatters a list of tensors to all processes in a group.\nEach process will receive exactly one tensor and store its data in thetensorargument.\ntensor\nComplex tensors are supported.\ntensor(Tensor) \u2013 Output tensor.\nscatter_list(list[Tensor]) \u2013 List of tensors to scatter (default is\nNone, must be specified on the source rank)\nsrc(int) \u2013 Source rank on global process group (regardless ofgroupargument).\n(If bothsrcandgroup_srcare None, default is global rank 0)\ngroup\nsrc\ngroup_src\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nasync_op(bool,optional) \u2013 Whether this op should be an async op\ngroup_src(int,optional) \u2013 Source rank ongroup.  Invalid to specify bothsrcandgroup_src\ngroup\nsrc\ngroup_src\nAsync work handle, if async_op is set to True.\nNone, if not async_op or if not part of the group\nNote\nNote that all Tensors in scatter_list must have the same size.\n\n```python\n>>> # Note: Process group initialization omitted on each rank.\n>>> import torch.distributed as dist\n>>> tensor_size = 2\n>>> device = torch.device(f'cuda:{rank}')\n>>> output_tensor = torch.zeros(tensor_size, device=device)\n>>> if dist.get_rank() == 0:\n>>>     # Assumes world_size of 2.\n>>>     # Only tensors, all of which must be the same size.\n>>>     t_ones = torch.ones(tensor_size, device=device)\n>>>     t_fives = torch.ones(tensor_size, device=device) * 5\n>>>     scatter_list = [t_ones, t_fives]\n>>> else:\n>>>     scatter_list = None\n>>> dist.scatter(output_tensor, scatter_list, src=0)\n>>> # Rank i gets scatter_list[i].\n>>> output_tensor\ntensor([1., 1.], device='cuda:0') # Rank 0\ntensor([5., 5.], device='cuda:1') # Rank 1\n\n```\n\nScatters picklable objects inscatter_object_input_listto the whole group.\nscatter_object_input_list\nSimilar toscatter(), but Python objects can be passed in. On\neach rank, the scattered object will be stored as the first element ofscatter_object_output_list. Note that all objects inscatter_object_input_listmust be picklable in order to be scattered.\nscatter()\nscatter_object_output_list\nscatter_object_input_list\nscatter_object_output_list(List[Any]) \u2013 Non-empty list whose first\nelement will store the object scattered to this rank.\nscatter_object_input_list(List[Any],optional) \u2013 List of input objects to scatter.\nEach object must be picklable. Only objects on thesrcrank will\nbe scattered, and the argument can beNonefor non-src ranks.\nsrc\nNone\nsrc(int) \u2013 Source rank from which to scatterscatter_object_input_list.\nSource rank is based on global process group (regardless ofgroupargument).\n(If bothsrcandgroup_srcare None, default is global rank 0)\nscatter_object_input_list\ngroup\nsrc\ngroup_src\ngroup(Optional[ProcessGroup]) \u2013 (ProcessGroup, optional): The process group to work on. If None,\nthe default process group will be used. Default isNone.\nNone\ngroup_src(int,optional) \u2013 Source rank ongroup.  Invalid to specify bothsrcandgroup_src\ngroup\nsrc\ngroup_src\nNone. If rank is part of the group,scatter_object_output_listwill have its first element set to the scattered object for this rank.\nNone\nscatter_object_output_list\nNote\nNote that this API differs slightly from the scatter collective\nsince it does not provide anasync_ophandle and thus will be a\nblocking call.\nasync_op\nWarning\nObject collectives have a number of serious performance and scalability\nlimitations.  SeeObject collectivesfor details.\nWarning\nscatter_object_list()usespicklemodule implicitly, which\nis known to be insecure. It is possible to construct malicious pickle\ndata which will execute arbitrary code during unpickling. Only call this\nfunction with data you trust.\nscatter_object_list()\npickle\nWarning\nCallingscatter_object_list()with GPU tensors is not well supported\nand inefficient as it incurs GPU -> CPU transfer since tensors would be\npickled. Please consider usingscatter()instead.\nscatter_object_list()\nscatter()\n\n```python\n>>> # Note: Process group initialization omitted on each rank.\n>>> import torch.distributed as dist\n>>> if dist.get_rank() == 0:\n>>>     # Assumes world_size of 3.\n>>>     objects = [\"foo\", 12, {1: 2}] # any picklable object\n>>> else:\n>>>     # Can be any list on non-src ranks, elements are not used.\n>>>     objects = [None, None, None]\n>>> output_list = [None]\n>>> dist.scatter_object_list(output_list, objects, src=0)\n>>> # Rank i gets objects[i]. For example, on rank 2:\n>>> output_list\n[{1: 2}]\n\n```\n\nReduces, then scatters a list of tensors to all processes in a group.\noutput(Tensor) \u2013 Output tensor.\ninput_list(list[Tensor]) \u2013 List of tensors to reduce and scatter.\nop(optional) \u2013 One of the values fromtorch.distributed.ReduceOpenum.  Specifies an operation used for element-wise reductions.\ntorch.distributed.ReduceOp\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nasync_op(bool,optional) \u2013 Whether this op should be an async op.\nAsync work handle, if async_op is set to True.\nNone, if not async_op or if not part of the group.\nReduces, then scatters a tensor to all ranks in a group.\noutput(Tensor) \u2013 Output tensor. It should have the same size across all\nranks.\ninput(Tensor) \u2013 Input tensor to be reduced and scattered. Its size\nshould be output tensor size times the world size. The input tensor\ncan have one of the following shapes:\n(i) a concatenation of the output tensors along the primary\ndimension, or\n(ii) a stack of the output tensors along the primary dimension.\nFor definition of \u201cconcatenation\u201d, seetorch.cat().\nFor definition of \u201cstack\u201d, seetorch.stack().\ntorch.cat()\ntorch.stack()\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nasync_op(bool,optional) \u2013 Whether this op should be an async op.\nAsync work handle, if async_op is set to True.\nNone, if not async_op or if not part of the group.\nExamples\n\n```python\n>>> # All tensors below are of torch.int64 dtype and on CUDA devices.\n>>> # We have two ranks.\n>>> device = torch.device(f\"cuda:{rank}\")\n>>> tensor_out = torch.zeros(2, dtype=torch.int64, device=device)\n>>> # Input in concatenation form\n>>> tensor_in = torch.arange(world_size * 2, dtype=torch.int64, device=device)\n>>> tensor_in\ntensor([0, 1, 2, 3], device='cuda:0') # Rank 0\ntensor([0, 1, 2, 3], device='cuda:1') # Rank 1\n>>> dist.reduce_scatter_tensor(tensor_out, tensor_in)\n>>> tensor_out\ntensor([0, 2], device='cuda:0') # Rank 0\ntensor([4, 6], device='cuda:1') # Rank 1\n>>> # Input in stack form\n>>> tensor_in = torch.reshape(tensor_in, (world_size, 2))\n>>> tensor_in\ntensor([[0, 1],\n        [2, 3]], device='cuda:0') # Rank 0\ntensor([[0, 1],\n        [2, 3]], device='cuda:1') # Rank 1\n>>> dist.reduce_scatter_tensor(tensor_out, tensor_in)\n>>> tensor_out\ntensor([0, 2], device='cuda:0') # Rank 0\ntensor([4, 6], device='cuda:1') # Rank 1\n\n```\n\nSplit input tensor and then scatter the split list to all processes in a group.\nLater the received tensors are concatenated from all the processes in the group\nand returned as a single output tensor.\nComplex tensors are supported.\noutput(Tensor) \u2013 Gathered concatenated output tensor.\ninput(Tensor) \u2013 Input tensor to scatter.\noutput_split_sizes\u2013 (list[Int], optional): Output split sizes for dim 0\nif specified None or empty, dim 0 ofoutputtensor must divide\nequally byworld_size.\noutput\nworld_size\ninput_split_sizes\u2013 (list[Int], optional): Input split sizes for dim 0\nif specified None or empty, dim 0 ofinputtensor must divide\nequally byworld_size.\ninput\nworld_size\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nasync_op(bool,optional) \u2013 Whether this op should be an async op.\nAsync work handle, if async_op is set to True.\nNone, if not async_op or if not part of the group.\nWarning\nall_to_all_singleis experimental and subject to change.\nExamples\n\n```python\n>>> input = torch.arange(4) + rank * 4\n>>> input\ntensor([0, 1, 2, 3])     # Rank 0\ntensor([4, 5, 6, 7])     # Rank 1\ntensor([8, 9, 10, 11])   # Rank 2\ntensor([12, 13, 14, 15]) # Rank 3\n>>> output = torch.empty([4], dtype=torch.int64)\n>>> dist.all_to_all_single(output, input)\n>>> output\ntensor([0, 4, 8, 12])    # Rank 0\ntensor([1, 5, 9, 13])    # Rank 1\ntensor([2, 6, 10, 14])   # Rank 2\ntensor([3, 7, 11, 15])   # Rank 3\n\n```\n\n\n```python\n>>> # Essentially, it is similar to following operation:\n>>> scatter_list = list(input.chunk(world_size))\n>>> gather_list = list(output.chunk(world_size))\n>>> for i in range(world_size):\n>>>     dist.scatter(gather_list[i], scatter_list if i == rank else [], src = i)\n\n```\n\n\n```python\n>>> # Another example with uneven split\n>>> input\ntensor([0, 1, 2, 3, 4, 5])                                       # Rank 0\ntensor([10, 11, 12, 13, 14, 15, 16, 17, 18])                     # Rank 1\ntensor([20, 21, 22, 23, 24])                                     # Rank 2\ntensor([30, 31, 32, 33, 34, 35, 36])                             # Rank 3\n>>> input_splits\n[2, 2, 1, 1]                                                     # Rank 0\n[3, 2, 2, 2]                                                     # Rank 1\n[2, 1, 1, 1]                                                     # Rank 2\n[2, 2, 2, 1]                                                     # Rank 3\n>>> output_splits\n[2, 3, 2, 2]                                                     # Rank 0\n[2, 2, 1, 2]                                                     # Rank 1\n[1, 2, 1, 2]                                                     # Rank 2\n[1, 2, 1, 1]                                                     # Rank 3\n>>> output = ...\n>>> dist.all_to_all_single(output, input, output_splits, input_splits)\n>>> output\ntensor([ 0,  1, 10, 11, 12, 20, 21, 30, 31])                     # Rank 0\ntensor([ 2,  3, 13, 14, 22, 32, 33])                             # Rank 1\ntensor([ 4, 15, 16, 23, 34, 35])                                 # Rank 2\ntensor([ 5, 17, 18, 24, 36])                                     # Rank 3\n\n```\n\n\n```python\n>>> # Another example with tensors of torch.cfloat type.\n>>> input = torch.tensor(\n...     [1 + 1j, 2 + 2j, 3 + 3j, 4 + 4j], dtype=torch.cfloat\n... ) + 4 * rank * (1 + 1j)\n>>> input\ntensor([1+1j, 2+2j, 3+3j, 4+4j])                                # Rank 0\ntensor([5+5j, 6+6j, 7+7j, 8+8j])                                # Rank 1\ntensor([9+9j, 10+10j, 11+11j, 12+12j])                          # Rank 2\ntensor([13+13j, 14+14j, 15+15j, 16+16j])                        # Rank 3\n>>> output = torch.empty([4], dtype=torch.int64)\n>>> dist.all_to_all_single(output, input)\n>>> output\ntensor([1+1j, 5+5j, 9+9j, 13+13j])                              # Rank 0\ntensor([2+2j, 6+6j, 10+10j, 14+14j])                            # Rank 1\ntensor([3+3j, 7+7j, 11+11j, 15+15j])                            # Rank 2\ntensor([4+4j, 8+8j, 12+12j, 16+16j])                            # Rank 3\n\n```\n\nScatters list of input tensors to all processes in a group and return gathered list of tensors in output list.\nComplex tensors are supported.\noutput_tensor_list(list[Tensor]) \u2013 List of tensors to be gathered one\nper rank.\ninput_tensor_list(list[Tensor]) \u2013 List of tensors to scatter one per rank.\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nasync_op(bool,optional) \u2013 Whether this op should be an async op.\nAsync work handle, if async_op is set to True.\nNone, if not async_op or if not part of the group.\nWarning\nall_to_allis experimental and subject to change.\nExamples\n\n```python\n>>> input = torch.arange(4) + rank * 4\n>>> input = list(input.chunk(4))\n>>> input\n[tensor([0]), tensor([1]), tensor([2]), tensor([3])]     # Rank 0\n[tensor([4]), tensor([5]), tensor([6]), tensor([7])]     # Rank 1\n[tensor([8]), tensor([9]), tensor([10]), tensor([11])]   # Rank 2\n[tensor([12]), tensor([13]), tensor([14]), tensor([15])] # Rank 3\n>>> output = list(torch.empty([4], dtype=torch.int64).chunk(4))\n>>> dist.all_to_all(output, input)\n>>> output\n[tensor([0]), tensor([4]), tensor([8]), tensor([12])]    # Rank 0\n[tensor([1]), tensor([5]), tensor([9]), tensor([13])]    # Rank 1\n[tensor([2]), tensor([6]), tensor([10]), tensor([14])]   # Rank 2\n[tensor([3]), tensor([7]), tensor([11]), tensor([15])]   # Rank 3\n\n```\n\n\n```python\n>>> # Essentially, it is similar to following operation:\n>>> scatter_list = input\n>>> gather_list = output\n>>> for i in range(world_size):\n>>>     dist.scatter(gather_list[i], scatter_list if i == rank else [], src=i)\n\n```\n\n\n```python\n>>> input\ntensor([0, 1, 2, 3, 4, 5])                                       # Rank 0\ntensor([10, 11, 12, 13, 14, 15, 16, 17, 18])                     # Rank 1\ntensor([20, 21, 22, 23, 24])                                     # Rank 2\ntensor([30, 31, 32, 33, 34, 35, 36])                             # Rank 3\n>>> input_splits\n[2, 2, 1, 1]                                                     # Rank 0\n[3, 2, 2, 2]                                                     # Rank 1\n[2, 1, 1, 1]                                                     # Rank 2\n[2, 2, 2, 1]                                                     # Rank 3\n>>> output_splits\n[2, 3, 2, 2]                                                     # Rank 0\n[2, 2, 1, 2]                                                     # Rank 1\n[1, 2, 1, 2]                                                     # Rank 2\n[1, 2, 1, 1]                                                     # Rank 3\n>>> input = list(input.split(input_splits))\n>>> input\n[tensor([0, 1]), tensor([2, 3]), tensor([4]), tensor([5])]                   # Rank 0\n[tensor([10, 11, 12]), tensor([13, 14]), tensor([15, 16]), tensor([17, 18])] # Rank 1\n[tensor([20, 21]), tensor([22]), tensor([23]), tensor([24])]                 # Rank 2\n[tensor([30, 31]), tensor([32, 33]), tensor([34, 35]), tensor([36])]         # Rank 3\n>>> output = ...\n>>> dist.all_to_all(output, input)\n>>> output\n[tensor([0, 1]), tensor([10, 11, 12]), tensor([20, 21]), tensor([30, 31])]   # Rank 0\n[tensor([2, 3]), tensor([13, 14]), tensor([22]), tensor([32, 33])]           # Rank 1\n[tensor([4]), tensor([15, 16]), tensor([23]), tensor([34, 35])]              # Rank 2\n[tensor([5]), tensor([17, 18]), tensor([24]), tensor([36])]                  # Rank 3\n\n```\n\n\n```python\n>>> # Another example with tensors of torch.cfloat type.\n>>> input = torch.tensor(\n...     [1 + 1j, 2 + 2j, 3 + 3j, 4 + 4j], dtype=torch.cfloat\n... ) + 4 * rank * (1 + 1j)\n>>> input = list(input.chunk(4))\n>>> input\n[tensor([1+1j]), tensor([2+2j]), tensor([3+3j]), tensor([4+4j])]            # Rank 0\n[tensor([5+5j]), tensor([6+6j]), tensor([7+7j]), tensor([8+8j])]            # Rank 1\n[tensor([9+9j]), tensor([10+10j]), tensor([11+11j]), tensor([12+12j])]      # Rank 2\n[tensor([13+13j]), tensor([14+14j]), tensor([15+15j]), tensor([16+16j])]    # Rank 3\n>>> output = list(torch.empty([4], dtype=torch.int64).chunk(4))\n>>> dist.all_to_all(output, input)\n>>> output\n[tensor([1+1j]), tensor([5+5j]), tensor([9+9j]), tensor([13+13j])]          # Rank 0\n[tensor([2+2j]), tensor([6+6j]), tensor([10+10j]), tensor([14+14j])]        # Rank 1\n[tensor([3+3j]), tensor([7+7j]), tensor([11+11j]), tensor([15+15j])]        # Rank 2\n[tensor([4+4j]), tensor([8+8j]), tensor([12+12j]), tensor([16+16j])]        # Rank 3\n\n```\n\nSynchronize all processes.\nThis collective blocks processes until the whole group enters this function,\nif async_op is False, or if async work handle is called on wait().\ngroup(ProcessGroup,optional) \u2013 The process group to work on. If None,\nthe default process group will be used.\nasync_op(bool,optional) \u2013 Whether this op should be an async op\ndevice_ids([int],optional) \u2013 List of device/GPU ids. Only one id is expected.\nAsync work handle, if async_op is set to True.\nNone, if not async_op or if not part of the group\nNote\nProcessGroupNCCLnow blocks the cpu thread till the completion of the barrier collective.\nNote\nProcessGroupNCCLimplements barrier as an all_reduce of a 1-element tensor. A device must be chosen\nfor allocating this tensor.  The device choice is made by checking in this order (1) the first device passed todevice_idsarg of barrier if not None, (2) the device passed to init_process_group if not None, (3) the device\nthat was first used with this process group, if another collective with tensor inputs has been performed, (4)\nthe device index indicated by the global rank mod local device count.\nSynchronize processes similar totorch.distributed.barrier, but consider a configurable timeout.\ntorch.distributed.barrier\nIt is able to report ranks that did not pass this barrier within the provided timeout.\nSpecifically, for non-zero ranks, will block until a send/recv is processed from rank 0.\nRank 0 will block until all send /recv from other ranks are processed, and will report\nfailures for ranks that failed to respond in time. Note that if one rank does not reach the\nmonitored_barrier (for example due to a hang), all other ranks would fail in monitored_barrier.\nThis collective will block all processes/ranks in the group, until the\nwhole group exits the function successfully, making it useful for debugging\nand synchronizing. However, it can have a performance impact and should only\nbe used for debugging or scenarios that require full synchronization points\non the host-side. For debugging purposes, this barrier can be inserted\nbefore the application\u2019s collective calls to check if any ranks are\ndesynchronized.\nNote\nNote that this collective is only supported with the GLOO backend.\ngroup(ProcessGroup,optional) \u2013 The process group to work on. IfNone, the default process group will be used.\nNone\ntimeout(datetime.timedelta,optional) \u2013 Timeout for monitored_barrier.\nIfNone, the default process group timeout will be used.\nNone\nwait_all_ranks(bool,optional) \u2013 Whether to collect all failed ranks or\nnot. By default, this isFalseandmonitored_barrieron rank 0\nwill throw on the first failed rank it encounters in order to fail\nfast. By settingwait_all_ranks=Truemonitored_barrierwill\ncollect all failed ranks and throw an error containing information\nabout all failed ranks.\nFalse\nmonitored_barrier\nwait_all_ranks=True\nmonitored_barrier\nNone.\nNone\n\n```python\n>>> # Note: Process group initialization omitted on each rank.\n>>> import torch.distributed as dist\n>>> if dist.get_rank() != 1:\n>>>     dist.monitored_barrier() # Raises exception indicating that\n>>> # rank 1 did not call into monitored_barrier.\n>>> # Example with wait_all_ranks=True\n>>> if dist.get_rank() == 0:\n>>>     dist.monitored_barrier(wait_all_ranks=True) # Raises exception\n>>> # indicating that ranks 1, 2, ... world_size - 1 did not call into\n>>> # monitored_barrier.\n\n```\n\nAWorkobject represents the handle to a pending asynchronous operation in\nPyTorch\u2019s distributed package. It is returned by non-blocking collective operations,\nsuch asdist.all_reduce(tensor, async_op=True).\nBlocks the currently active GPU stream on the operation to\ncomplete. For GPU based collectives this is equivalent to\nsynchronize. For CPU initiated collectives such as with Gloo this\nwill block the CUDA stream until the operation is complete.\nThis returns immediately in all cases.\nTo check whether an operation was successful you should check the\nWork object result asynchronously.\nAtorch.futures.Futureobject which is associated with the completion of\ntheWork. As an example, a future object can be retrieved\nbyfut=process_group.allreduce(tensors).get_future().\ntorch.futures.Future\nWork\nfut=process_group.allreduce(tensors).get_future()\nBelow is an example of a simple allreduce DDP communication hook that usesget_futureAPI to retrieve a Future associated with the completion ofallreduce.\nget_future\nallreduce\n\n```python\n>>> def allreduce(process_group: dist.ProcessGroup, bucket: dist.GradBucket): -> torch.futures.Future\n>>>     group_to_use = process_group if process_group is not None else torch.distributed.group.WORLD\n>>>     tensor = bucket.buffer().div_(group_to_use.size())\n>>>     return torch.distributed.all_reduce(tensor, group=group_to_use, async_op=True).get_future()\n>>> ddp_model.register_comm_hook(state=None, hook=allreduce)\n\n```\n\nWarning\nget_futureAPI supports NCCL, and partially GLOO and MPI backends\n(no support for peer-to-peer operations like send/recv) and will return atorch.futures.Future.\nget_future\ntorch.futures.Future\nIn the example above,allreducework will be done on GPU using NCCL backend,fut.wait()will return after synchronizing the appropriate NCCL streams\nwith PyTorch\u2019s current device streams to ensure we can have asynchronous CUDA\nexecution and it does not wait for the entire operation to complete on GPU. Note thatCUDAFuturedoes not supportTORCH_NCCL_BLOCKING_WAITflag or NCCL\u2019sbarrier().\nIn addition, if a callback function was added byfut.then(), it will wait untilWorkNCCL\u2019s NCCL streams synchronize withProcessGroupNCCL\u2019s dedicated callback\nstream and invoke the callback inline after running the callback on the callback stream.fut.then()will return anotherCUDAFuturethat holds the return value of the\ncallback and aCUDAEventthat recorded the callback stream.\nallreduce\nfut.wait()\nCUDAFuture\nTORCH_NCCL_BLOCKING_WAIT\nbarrier()\nfut.then()\nWorkNCCL\nProcessGroupNCCL\nfut.then()\nCUDAFuture\nCUDAEvent\nFor CPU work,fut.done()returns true when work has been completed and value()\ntensors are ready.\nfut.done()\nFor GPU work,fut.done()returns true only whether the operation has been enqueued.\nfut.done()\nFor mixed CPU-GPU work (e.g. sending GPU tensors with GLOO),fut.done()returns\ntrue when tensors have arrived on respective nodes, but not yet necessarily synched on\nrespective GPUs (similarly to GPU work).\nfut.done()\nAtorch.futures.Futureobject of int type which maps to the enum type of WorkResult\nAs an example, a future object can be retrieved\nbyfut=process_group.allreduce(tensor).get_future_result().\ntorch.futures.Future\nfut=process_group.allreduce(tensor).get_future_result()\nusers can usefut.wait()to blocking wait for the completion of the work and\nget the WorkResult byfut.value().\nAlso, users can usefut.then(call_back_func)to register a callback function to be called\nwhen the work is completed, without blocking the current thread.\nfut.wait()\nfut.value()\nfut.then(call_back_func)\nWarning\nget_future_resultAPI supports NCCL\nget_future_result\ntrue/false.\nwork.wait(timeout)\n# some handling\nWarning\nIn normal cases, users do not need to set the timeout.\ncalling wait() is the same as calling synchronize():\nLetting the current stream block on the completion of the NCCL work.\nHowever, if timeout is set, it will block the CPU thread until the NCCL work is completed\nor timed out. If timeout, exception will be thrown.\nAn enum-like class for available reduction operations:SUM,PRODUCT,MIN,MAX,BAND,BOR,BXOR, andPREMUL_SUM.\nSUM\nPRODUCT\nMIN\nMAX\nBAND\nBOR\nBXOR\nPREMUL_SUM\nBAND,BOR, andBXORreductions are not available when\nusing theNCCLbackend.\nBAND\nBOR\nBXOR\nNCCL\nAVGdivides values by the world size before summing across ranks.AVGis only available with theNCCLbackend,\nand only for NCCL versions 2.10 or later.\nAVG\nAVG\nNCCL\nPREMUL_SUMmultiplies inputs by a given scalar locally before reduction.PREMUL_SUMis only available with theNCCLbackend,\nand only available for NCCL versions 2.11 or later. Users are supposed to\nusetorch.distributed._make_nccl_premul_sum.\nPREMUL_SUM\nPREMUL_SUM\nNCCL\ntorch.distributed._make_nccl_premul_sum\nAdditionally,MAX,MINandPRODUCTare not supported for complex tensors.\nMAX\nMIN\nPRODUCT\nThe values of this class can be accessed as attributes, e.g.,ReduceOp.SUM.\nThey are used in specifying strategies for reduction collectives, e.g.,reduce().\nReduceOp.SUM\nreduce()\nThis class does not support__members__property.\n__members__\nDeprecated enum-like class for reduction operations:SUM,PRODUCT,MIN, andMAX.\nSUM\nPRODUCT\nMIN\nMAX\nReduceOpis recommended to use instead.\nReduceOp\n\n## Distributed Key-Value Store#\n\nThe distributed package comes with a distributed key-value store, which can be\nused to share information between processes in the group as well as to\ninitialize the distributed package intorch.distributed.init_process_group()(by explicitly creating the store\nas an alternative to specifyinginit_method.) There are 3 choices for\nKey-Value Stores:TCPStore,FileStore, andHashStore.\ntorch.distributed.init_process_group()\ninit_method\nTCPStore\nFileStore\nHashStore\nBase class for all store implementations, such as the 3 provided by PyTorch\ndistributed: (TCPStore,FileStore,\nandHashStore).\nTCPStore\nFileStore\nHashStore\nThe first call to add for a givenkeycreates a counter associated\nwithkeyin the store, initialized toamount. Subsequent calls to add\nwith the samekeyincrement the counter by the specifiedamount.\nCallingadd()with a key that has already\nbeen set in the store byset()will result\nin an exception.\nkey\nkey\namount\nkey\namount\nadd()\nset()\nkey(str) \u2013 The key in the store whose counter will be incremented.\namount(int) \u2013 The quantity by which the counter will be incremented.\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> # Using TCPStore as an example, other store types can also be used\n>>> store = dist.TCPStore(\"127.0.0.1\", 0, 1, True, timedelta(seconds=30))\n>>> store.add(\"first_key\", 1)\n>>> store.add(\"first_key\", 6)\n>>> # Should return 7\n>>> store.get(\"first_key\")\n\n```\n\nAppend the key-value pair into the store based on the suppliedkeyandvalue. Ifkeydoes not exists in the store, it will be created.\nkey\nvalue\nkey\nkey(str) \u2013 The key to be appended to the store.\nvalue(str) \u2013 The value associated withkeyto be added to the store.\nkey\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> store = dist.TCPStore(\"127.0.0.1\", 0, 1, True, timedelta(seconds=30))\n>>> store.append(\"first_key\", \"po\")\n>>> store.append(\"first_key\", \"tato\")\n>>> # Should return \"potato\"\n>>> store.get(\"first_key\")\n\n```\n\nThe call to check whether a given list ofkeyshave value stored in\nthe store. This call immediately returns in normal cases but still suffers\nfrom some edge deadlock cases, e.g, calling check after TCPStore has been destroyed.\nCallingcheck()with a list of keys that\none wants to check whether stored in the store or not.\nkeys\ncheck()\nkeys(list[str]) \u2013 The keys to query whether stored in the store.\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> # Using TCPStore as an example, other store types can also be used\n>>> store = dist.TCPStore(\"127.0.0.1\", 0, 1, True, timedelta(seconds=30))\n>>> store.add(\"first_key\", 1)\n>>> # Should return 7\n>>> store.check([\"first_key\"])\n\n```\n\nClones the store and returns a new object that points to the same underlying\nstore. The returned store can be used concurrently with the original object.\nThis is intended to provide a safe way to use a store from multiple threads by\ncloning one store per thread.\nInserts the key-value pair into the store based on the suppliedkeyand\nperforms comparison betweenexpected_valueanddesired_valuebefore inserting.desired_valuewill only be set ifexpected_valuefor thekeyalready exists in the store or ifexpected_valueis an empty string.\nkey\nexpected_value\ndesired_value\ndesired_value\nexpected_value\nkey\nexpected_value\nkey(str) \u2013 The key to be checked in the store.\nexpected_value(str) \u2013 The value associated withkeyto be checked before insertion.\nkey\ndesired_value(str) \u2013 The value associated withkeyto be added to the store.\nkey\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> store = dist.TCPStore(\"127.0.0.1\", 0, 1, True, timedelta(seconds=30))\n>>> store.set(\"key\", \"first_value\")\n>>> store.compare_set(\"key\", \"first_value\", \"second_value\")\n>>> # Should return \"second_value\"\n>>> store.get(\"key\")\n\n```\n\nDeletes the key-value pair associated withkeyfrom the store. Returnstrueif the key was successfully deleted, andfalseif it was not.\nkey\nWarning\nThedelete_keyAPI is only supported by theTCPStoreandHashStore. Using this API\nwith theFileStorewill result in an exception.\ndelete_key\nTCPStore\nHashStore\nFileStore\nkey(str) \u2013 The key to be deleted from the store\nTrueifkeywas deleted, otherwiseFalse.\nkey\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> # Using TCPStore as an example, HashStore can also be used\n>>> store = dist.TCPStore(\"127.0.0.1\", 0, 1, True, timedelta(seconds=30))\n>>> store.set(\"first_key\")\n>>> # This should return true\n>>> store.delete_key(\"first_key\")\n>>> # This should return false\n>>> store.delete_key(\"bad_key\")\n\n```\n\nRetrieves the value associated with the givenkeyin the store. Ifkeyis not\npresent in the store, the function will wait fortimeout, which is defined\nwhen initializing the store, before throwing an exception.\nkey\nkey\ntimeout\nkey(str) \u2013 The function will return the value associated with this key.\nValue associated withkeyifkeyis in the store.\nkey\nkey\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> store = dist.TCPStore(\"127.0.0.1\", 0, 1, True, timedelta(seconds=30))\n>>> store.set(\"first_key\", \"first_value\")\n>>> # Should return \"first_value\"\n>>> store.get(\"first_key\")\n\n```\n\nReturns true if the store supports extended operations.\nRetrieve all values inkeys. If any key inkeysis not\npresent in the store, the function will wait fortimeout\nkeys\nkeys\ntimeout\nkeys(List[str]) \u2013 The keys to be retrieved from the store.\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> store = dist.TCPStore(\"127.0.0.1\", 0, 1, True, timedelta(seconds=30))\n>>> store.set(\"first_key\", \"po\")\n>>> store.set(\"second_key\", \"tato\")\n>>> # Should return [b\"po\", b\"tato\"]\n>>> store.multi_get([\"first_key\", \"second_key\"])\n\n```\n\nInserts a list key-value pair into the store based on the suppliedkeysandvalues\nkeys\nvalues\nkeys(List[str]) \u2013 The keys to insert.\nvalues(List[str]) \u2013 The values to insert.\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> store = dist.TCPStore(\"127.0.0.1\", 0, 1, True, timedelta(seconds=30))\n>>> store.multi_set([\"first_key\", \"second_key\"], [\"po\", \"tato\"])\n>>> # Should return b\"po\"\n>>> store.get(\"first_key\")\n\n```\n\nReturns the number of keys set in the store. Note that this number will typically\nbe one greater than the number of keys added byset()andadd()since one key is used to coordinate all\nthe workers using the store.\nset()\nadd()\nWarning\nWhen used with theTCPStore,num_keysreturns the number of keys written to the underlying file. If the store is destructed and another store is created with the same file, the original keys will be retained.\nTCPStore\nnum_keys\nThe number of keys present in the store.\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> # Using TCPStore as an example, other store types can also be used\n>>> store = dist.TCPStore(\"127.0.0.1\", 0, 1, True, timedelta(seconds=30))\n>>> store.set(\"first_key\", \"first_value\")\n>>> # This should return 2\n>>> store.num_keys()\n\n```\n\nReturns the length of the specified queue.\nIf the queue doesn\u2019t exist it returns 0.\nSee queue_push for more details.\nkey(str) \u2013 The key of the queue to get the length.\nPops a value from the specified queue or waits until timeout if the queue is empty.\nSee queue_push for more details.\nIf block is False, a dist.QueueEmptyError will be raised if the queue is empty.\nkey(str) \u2013 The key of the queue to pop from.\nblock(bool) \u2013 Whether to block waiting for the key or immediately return.\nPushes a value into the specified queue.\nUsing the same key for queues and set/get operations may result in unexpected\nbehavior.\nwait/check operations are supported for queues.\nwait with queues will only wake one waiting worker rather than all.\nkey(str) \u2013 The key of the queue to push to.\nvalue(str) \u2013 The value to push into the queue.\nInserts the key-value pair into the store based on the suppliedkeyandvalue. Ifkeyalready exists in the store, it will overwrite the old\nvalue with the new suppliedvalue.\nkey\nvalue\nkey\nvalue\nkey(str) \u2013 The key to be added to the store.\nvalue(str) \u2013 The value associated withkeyto be added to the store.\nkey\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> store = dist.TCPStore(\"127.0.0.1\", 0, 1, True, timedelta(seconds=30))\n>>> store.set(\"first_key\", \"first_value\")\n>>> # Should return \"first_value\"\n>>> store.get(\"first_key\")\n\n```\n\nSets the store\u2019s default timeout. This timeout is used during initialization and inwait()andget().\nwait()\nget()\ntimeout(timedelta) \u2013 timeout to be set in the store.\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> # Using TCPStore as an example, other store types can also be used\n>>> store = dist.TCPStore(\"127.0.0.1\", 0, 1, True, timedelta(seconds=30))\n>>> store.set_timeout(timedelta(seconds=10))\n>>> # This will throw an exception after 10 seconds\n>>> store.wait([\"bad_key\"])\n\n```\n\nGets the timeout of the store.\nOverloaded function.\nwait(self: torch._C._distributed_c10d.Store, arg0: collections.abc.Sequence[str]) -> None\nWaits for each key inkeysto be added to the store. If not all keys are\nset before thetimeout(set during store initialization), thenwaitwill throw an exception.\nkeys\ntimeout\nwait\nkeys(list) \u2013 List of keys on which to wait until they are set in the store.\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> # Using TCPStore as an example, other store types can also be used\n>>> store = dist.TCPStore(\"127.0.0.1\", 0, 1, True, timedelta(seconds=30))\n>>> # This will throw an exception after 30 seconds\n>>> store.wait([\"bad_key\"])\n\n```\n\nwait(self: torch._C._distributed_c10d.Store, arg0: collections.abc.Sequence[str], arg1: datetime.timedelta) -> None\nWaits for each key inkeysto be added to the store, and throws an exception\nif the keys have not been set by the suppliedtimeout.\nkeys\ntimeout\nkeys(list) \u2013 List of keys on which to wait until they are set in the store.\ntimeout(timedelta) \u2013 Time to wait for the keys to be added before throwing an exception.\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> # Using TCPStore as an example, other store types can also be used\n>>> store = dist.TCPStore(\"127.0.0.1\", 0, 1, True, timedelta(seconds=30))\n>>> # This will throw an exception after 10 seconds\n>>> store.wait([\"bad_key\"], timedelta(seconds=10))\n\n```\n\nA TCP-based distributed key-value store implementation. The server store holds\nthe data, while the client stores can connect to the server store over TCP and\nperform actions such asset()to insert a key-value\npair,get()to retrieve a key-value pair, etc. There\nshould always be one server store initialized because the client store(s) will wait for\nthe server to establish a connection.\nset()\nget()\nhost_name(str) \u2013 The hostname or IP Address the server store should run on.\nport(int) \u2013 The port on which the server store should listen for incoming requests.\nworld_size(int,optional) \u2013 The total number of store users (number of clients + 1 for the server). Default is None (None indicates a non-fixed number of store users).\nis_master(bool,optional) \u2013 True when initializing the server store and False for client stores. Default is False.\ntimeout(timedelta,optional) \u2013 Timeout used by the store during initialization and for methods such asget()andwait(). Default is timedelta(seconds=300)\nget()\nwait()\nwait_for_workers(bool,optional) \u2013 Whether to wait for all the workers to connect with the server store. This is only applicable when world_size is a fixed value. Default is True.\nmulti_tenant(bool,optional) \u2013 If True, allTCPStoreinstances in the current process with the same host/port will use the same underlyingTCPServer. Default is False.\nTCPStore\nTCPServer\nmaster_listen_fd(int,optional) \u2013 If specified, the underlyingTCPServerwill listen on this file descriptor, which must be a socket already bound toport. To bind an ephemeral port we recommend setting the port to 0 and reading.port. Default is None (meaning the server creates a new socket and attempts to bind it toport).\nTCPServer\nport\n.port\nport\nuse_libuv(bool,optional) \u2013 If True, use libuv forTCPServerbackend. Default is True.\nTCPServer\n\n```python\n>>> import torch.distributed as dist\n>>> from datetime import timedelta\n>>> # Run on process 1 (server)\n>>> server_store = dist.TCPStore(\"127.0.0.1\", 1234, 2, True, timedelta(seconds=30))\n>>> # Run on process 2 (client)\n>>> client_store = dist.TCPStore(\"127.0.0.1\", 1234, 2, False)\n>>> # Use any of the store methods from either the client or server after initialization\n>>> server_store.set(\"first_key\", \"first_value\")\n>>> client_store.get(\"first_key\")\n\n```\n\nCreates a new TCPStore.\nGets the hostname on which the store listens for requests.\nReturns True if it\u2019s using the libuv backend.\nGets the port number on which the store listens for requests.\nA thread-safe store implementation based on an underlying hashmap. This store can be used\nwithin the same process (for example, by other threads), but cannot be used across processes.\n\n```python\n>>> import torch.distributed as dist\n>>> store = dist.HashStore()\n>>> # store can be used from other threads\n>>> # Use any of the store methods after initialization\n>>> store.set(\"first_key\", \"first_value\")\n\n```\n\nCreates a new HashStore.\nA store implementation that uses a file to store the underlying key-value pairs.\nfile_name(str) \u2013 path of the file in which to store the key-value pairs\nworld_size(int,optional) \u2013 The total number of processes using the store. Default is -1 (a negative value indicates a non-fixed number of store users).\n\n```python\n>>> import torch.distributed as dist\n>>> store1 = dist.FileStore(\"/tmp/filestore\", 2)\n>>> store2 = dist.FileStore(\"/tmp/filestore\", 2)\n>>> # Use any of the store methods from either the client or server after initialization\n>>> store1.set(\"first_key\", \"first_value\")\n>>> store2.get(\"first_key\")\n\n```\n\nCreates a new FileStore.\nGets the path of the file used by FileStore to store key-value pairs.\nA wrapper around any of the 3 key-value stores (TCPStore,FileStore, andHashStore)\nthat adds a prefix to each key inserted to the store.\nTCPStore\nFileStore\nHashStore\nprefix(str) \u2013 The prefix string that is prepended to each key before being inserted into the store.\nstore(torch.distributed.store) \u2013 A store object that forms the underlying key-value store.\nCreates a new PrefixStore.\nGets the underlying store object that PrefixStore wraps around.\n\n## Profiling Collective Communication#\n\nNote that you can usetorch.profiler(recommended, only available after 1.8.1) ortorch.autograd.profilerto profile collective communication and point-to-point communication APIs mentioned here. All out-of-the-box backends (gloo,nccl,mpi) are supported and collective communication usage will be rendered as expected in profiling output/traces. Profiling your code is the same as any regular torch operator:\ntorch.profiler\ntorch.autograd.profiler\ngloo\nnccl\nmpi\n\n```python\nimport torch\nimport torch.distributed as dist\nwith torch.profiler():\n    tensor = torch.randn(20, 10)\n    dist.all_reduce(tensor)\n\n```\n\nPlease refer to theprofiler documentationfor a full overview of profiler features.\n\n## Multi-GPU collective functions#\n\nWarning\nThe multi-GPU functions (which stand for multiple GPUs per CPU thread) are\ndeprecated. As of today, PyTorch Distributed\u2019s preferred programming model\nis one device per thread, as exemplified by the APIs in this document. If\nyou are a backend developer and want to support multiple devices per thread,\nplease contact PyTorch Distributed\u2019s maintainers.\n\n## Object collectives#\n\nWarning\nObject collectives have a number of serious limitations. Read further to determine\nif they are safe to use for your use case.\nObject collectives are a set of collective-like operations that work on arbitrary\nPython objects, as long as they can be pickled. There are various collective patterns\nimplemented (e.g. broadcast, all_gather, \u2026) but they each roughly follow this pattern:\nconvert the input object into a pickle (raw bytes), then shove it into a byte tensor\ncommunicate the size of this byte tensor to peers (first collective operation)\nallocate appropriately sized tensor to perform the real collective\ncommunicate the object data (second collective operation)\nconvert raw data back into Python (unpickle)\nObject collectives sometimes have surprising performance or memory characteristics that lead to\nlong runtimes or OOMs, and thus they should be used with caution. Here are some common issues.\nAsymmetric pickle/unpickle time- Pickling objects can be slow, depending on the number, type and size of the objects.\nWhen the collective has a fan-in (e.g. gather_object), the receiving rank(s) must unpickle N times more objects than\nthe sending rank(s) had to pickle, which can cause other ranks to time out on their next collective.\nInefficient tensor communication- Tensors should be sent via regular collective APIs, not object collective APIs.\nIt is possible to send Tensors via object collective APIs, but they will be serialized and deserialized (including a\nCPU-sync and device-to-host copy in the case of non-CPU tensors), and in almost every case other than debugging or\ntroubleshooting code, it would be worth the trouble to refactor the code to use non-object collectives instead.\nUnexpected tensor devices- If you still want to send tensors via object collectives, there is another aspect\nspecific to cuda (and possibly other accelerators) tensors. If you pickle a tensor that is currently oncuda:3, and\nthen unpickle it, you will get another tensor oncuda:3regardless of which process you are on, or which CUDA device\nis the \u2018default\u2019 device for that process. With regular tensor collective APIs, \u2018output tensors\u2019 will always be on the\nsame, local device, which is generally what you\u2019d expect.\ncuda:3\ncuda:3\nUnpickling a tensor will implicitly activate a CUDA context if it is the first\ntime a GPU is used by the process, which can waste significant amounts of GPU memory. This issue can be avoided by\nmoving tensors to CPU before passing them as inputs to an object collective.\n\n## Third-party backends#\n\nBesides the builtin GLOO/MPI/NCCL backends, PyTorch distributed supports\nthird-party backends through a run-time register mechanism.\nFor references on how to develop a third-party backend through C++ Extension,\nplease refer toTutorials - Custom C++ and CUDA Extensionsandtest/cpp_extensions/cpp_c10d_extension.cpp. The capability of third-party\nbackends are decided by their own implementations.\ntest/cpp_extensions/cpp_c10d_extension.cpp\nThe new backend derives fromc10d::ProcessGroupand registers the backend\nname and the instantiating interface throughtorch.distributed.Backend.register_backend()when imported.\nc10d::ProcessGroup\ntorch.distributed.Backend.register_backend()\nWhen manually importing this backend and invokingtorch.distributed.init_process_group()with the corresponding backend name, thetorch.distributedpackage runs on\nthe new backend.\ntorch.distributed.init_process_group()\ntorch.distributed\nWarning\nThe support of third-party backend is experimental and subject to change.\n\n## Launch utility#\n\nThetorch.distributedpackage also provides a launch utility intorch.distributed.launch. This helper utility can be used to launch\nmultiple processes per node for distributed training.\ntorch.distributed\ntorch.distributed.launch\nModuletorch.distributed.launch.\ntorch.distributed.launch\ntorch.distributed.launchis a module that spawns up multiple distributed\ntraining processes on each of the training nodes.\ntorch.distributed.launch\nWarning\nThis module is going to be deprecated in favor oftorchrun.\nThe utility can be used for single-node distributed training, in which one or\nmore processes per node will be spawned. The utility can be used for either\nCPU training or GPU training. If the utility is used for GPU training,\neach distributed process will be operating on a single GPU. This can achieve\nwell-improved single-node training performance. It can also be used in\nmulti-node distributed training, by spawning up multiple processes on each node\nfor well-improved multi-node distributed training performance as well.\nThis will especially be beneficial for systems with multiple Infiniband\ninterfaces that have direct-GPU support, since all of them can be utilized for\naggregated communication bandwidth.\nIn both cases of single-node distributed training or multi-node distributed\ntraining, this utility will launch the given number of processes per node\n(--nproc-per-node). If used for GPU training, this number needs to be less\nor equal to the number of GPUs on the current system (nproc_per_node),\nand each process will be operating on a single GPU fromGPU 0 to\nGPU (nproc_per_node - 1).\n--nproc-per-node\nnproc_per_node\nHow to use this module:\nSingle-Node multi-process distributed training\n\n```python\npython -m torch.distributed.launch --nproc-per-node=NUM_GPUS_YOU_HAVE\n           YOUR_TRAINING_SCRIPT.py (--arg1 --arg2 --arg3 and all other\n           arguments of your training script)\n\n```\n\nMulti-Node multi-process distributed training: (e.g. two nodes)\nNode 1:(IP: 192.168.1.1, and has a free port: 1234)\n\n```python\npython -m torch.distributed.launch --nproc-per-node=NUM_GPUS_YOU_HAVE\n           --nnodes=2 --node-rank=0 --master-addr=\"192.168.1.1\"\n           --master-port=1234 YOUR_TRAINING_SCRIPT.py (--arg1 --arg2 --arg3\n           and all other arguments of your training script)\n\n```\n\nNode 2:\n\n```python\npython -m torch.distributed.launch --nproc-per-node=NUM_GPUS_YOU_HAVE\n           --nnodes=2 --node-rank=1 --master-addr=\"192.168.1.1\"\n           --master-port=1234 YOUR_TRAINING_SCRIPT.py (--arg1 --arg2 --arg3\n           and all other arguments of your training script)\n\n```\n\nTo look up what optional arguments this module offers:\n\n```python\npython -m torch.distributed.launch --help\n\n```\n\nImportant Notices:\n1. This utility and multi-process distributed (single-node or\nmulti-node) GPU training currently only achieves the best performance using\nthe NCCL distributed backend. Thus NCCL backend is the recommended backend to\nuse for GPU training.\n2. In your training program, you must parse the command-line argument:--local-rank=LOCAL_PROCESS_RANK, which will be provided by this module.\nIf your training program uses GPUs, you should ensure that your code only\nruns on the GPU device of LOCAL_PROCESS_RANK. This can be done by:\n--local-rank=LOCAL_PROCESS_RANK\nParsing the local_rank argument\n\n```python\n>>> import argparse\n>>> parser = argparse.ArgumentParser()\n>>> parser.add_argument(\"--local-rank\", \"--local_rank\", type=int)\n>>> args = parser.parse_args()\n\n```\n\nSet your device to local rank using either\n\n```python\n>>> torch.cuda.set_device(args.local_rank)  # before your code runs\n\n```\n\nor\n\n```python\n>>> with torch.cuda.device(args.local_rank):\n>>>    # your code to run\n>>>    ...\n\n```\n\nChanged in version 2.0.0:The launcher will passes the--local-rank=<rank>argument to your script.\nFrom PyTorch 2.0.0 onwards, the dashed--local-rankis preferred over the\npreviously used underscored--local_rank.\n--local-rank=<rank>\n--local-rank\n--local_rank\nFor backward compatibility, it may be necessary for users to handle both\ncases in their argument parsing code. This means including both\"--local-rank\"and\"--local_rank\"in the argument parser. If only\"--local_rank\"is\nprovided, the launcher will trigger an error: \u201cerror: unrecognized arguments:\n\u2013local-rank=<rank>\u201d. For training code that only supports PyTorch 2.0.0+,\nincluding\"--local-rank\"should be sufficient.\n\"--local-rank\"\n\"--local_rank\"\n\"--local_rank\"\n\"--local-rank\"\n3. In your training program, you are supposed to call the following function\nat the beginning to start the distributed backend. It is strongly recommended\nthatinit_method=env://. Other init methods (e.g.tcp://) may work,\nbutenv://is the one that is officially supported by this module.\ninit_method=env://\ntcp://\nenv://\n\n```python\n>>> torch.distributed.init_process_group(backend='YOUR BACKEND',\n>>>                                      init_method='env://')\n\n```\n\n4. In your training program, you can either use regular distributed functions\nor usetorch.nn.parallel.DistributedDataParallel()module. If your\ntraining program uses GPUs for training and you would like to usetorch.nn.parallel.DistributedDataParallel()module,\nhere is how to configure it.\ntorch.nn.parallel.DistributedDataParallel()\ntorch.nn.parallel.DistributedDataParallel()\n\n```python\n>>> model = torch.nn.parallel.DistributedDataParallel(model,\n>>>                                                   device_ids=[args.local_rank],\n>>>                                                   output_device=args.local_rank)\n\n```\n\nPlease ensure thatdevice_idsargument is set to be the only GPU device id\nthat your code will be operating on. This is generally the local rank of the\nprocess. In other words, thedevice_idsneeds to be[args.local_rank],\nandoutput_deviceneeds to beargs.local_rankin order to use this\nutility\ndevice_ids\ndevice_ids\n[args.local_rank]\noutput_device\nargs.local_rank\n5. Another way to passlocal_rankto the subprocesses via environment variableLOCAL_RANK. This behavior is enabled when you launch the script with--use-env=True. You must adjust the subprocess example above to replaceargs.local_rankwithos.environ['LOCAL_RANK']; the launcher\nwill not pass--local-rankwhen you specify this flag.\nlocal_rank\nLOCAL_RANK\n--use-env=True\nargs.local_rank\nos.environ['LOCAL_RANK']\n--local-rank\nWarning\nlocal_rankis NOT globally unique: it is only unique per process\non a machine.  Thus, don\u2019t use it to decide if you should, e.g.,\nwrite to a networked filesystem.  Seepytorch/pytorch#12042for an example of\nhow things can go wrong if you don\u2019t do this correctly.\nlocal_rank\n\n## Spawn utility#\n\nTheMultiprocessing package - torch.multiprocessingpackage also provides aspawnfunction intorch.multiprocessing.spawn(). This helper function\ncan be used to spawn multiple processes. It works by passing in the\nfunction that you want to run and spawns N processes to run it. This\ncan be used for multiprocess distributed training as well.\nspawn\ntorch.multiprocessing.spawn()\nFor references on how to use it, please refer toPyTorch example - ImageNet\nimplementation\nNote that this function requires Python 3.4 or higher.\n\n## Debuggingtorch.distributedapplications#\n\ntorch.distributed\nDebugging distributed applications can be challenging due to hard to understand hangs, crashes, or inconsistent behavior across ranks.torch.distributedprovides\na suite of tools to help debug training applications in a self-serve fashion:\ntorch.distributed\n\n## Python Breakpoint#\n\nIt is extremely convenient to use python\u2019s debugger in a distributed environment, but because it does not work out of the box many people do not use it at all.\nPyTorch offers a customized wrapper around pdb that streamlines the process.\ntorch.distributed.breakpointmakes this process easy. Internally, it customizespdb\u2019s breakpoint behavior in two ways but otherwise behaves as normalpdb.\ntorch.distributed.breakpoint\npdb\npdb\nAttaches the debugger only on one rank (specified by the user).\nEnsures all other ranks stop, by using atorch.distributed.barrier()that will release once the debugged rank issues acontinue\ntorch.distributed.barrier()\ncontinue\nReroutes stdin from the child process such that it connects to your terminal.\nTo use it, simply issuetorch.distributed.breakpoint(rank)on all ranks, using the same value forrankin each case.\ntorch.distributed.breakpoint(rank)\nrank\n\n## Monitored Barrier#\n\nAs of v1.10,torch.distributed.monitored_barrier()exists as an alternative totorch.distributed.barrier()which fails with helpful information about which rank may be faulty\nwhen crashing, i.e. not all ranks calling intotorch.distributed.monitored_barrier()within the provided timeout.torch.distributed.monitored_barrier()implements a host-side\nbarrier usingsend/recvcommunication primitives in a process similar to acknowledgements, allowing rank 0 to report which rank(s) failed to acknowledge\nthe barrier in time. As an example, consider the following function where rank 1 fails to call intotorch.distributed.monitored_barrier()(in practice this could be due\nto an application bug or hang in a previous collective):\ntorch.distributed.monitored_barrier()\ntorch.distributed.barrier()\ntorch.distributed.monitored_barrier()\ntorch.distributed.monitored_barrier()\nsend\nrecv\ntorch.distributed.monitored_barrier()\n\n```python\nimport os\nfrom datetime import timedelta\n\nimport torch\nimport torch.distributed as dist\nimport torch.multiprocessing as mp\n\n\ndef worker(rank):\n    dist.init_process_group(\"nccl\", rank=rank, world_size=2)\n    # monitored barrier requires gloo process group to perform host-side sync.\n    group_gloo = dist.new_group(backend=\"gloo\")\n    if rank not in [1]:\n        dist.monitored_barrier(group=group_gloo, timeout=timedelta(seconds=2))\n\n\nif __name__ == \"__main__\":\n    os.environ[\"MASTER_ADDR\"] = \"localhost\"\n    os.environ[\"MASTER_PORT\"] = \"29501\"\n    mp.spawn(worker, nprocs=2, args=())\n\n```\n\nThe following error message is produced on rank 0, allowing the user to determine which rank(s) may be faulty and investigate further:\n\n```python\nRuntimeError: Rank 1 failed to pass monitoredBarrier in 2000 ms\n Original exception:\n[gloo/transport/tcp/pair.cc:598] Connection closed by peer [2401:db00:eef0:1100:3560:0:1c05:25d]:8594\n\n```\n\n\n## TORCH_DISTRIBUTED_DEBUG#\n\nTORCH_DISTRIBUTED_DEBUG\nWithTORCH_CPP_LOG_LEVEL=INFO, the environment variableTORCH_DISTRIBUTED_DEBUGcan be used to trigger additional useful logging and collective synchronization checks to ensure all ranks\nare synchronized appropriately.TORCH_DISTRIBUTED_DEBUGcan be set to eitherOFF(default),INFO, orDETAILdepending on the debugging level\nrequired. Please note that the most verbose option,DETAILmay impact the application performance and thus should only be used when debugging issues.\nTORCH_CPP_LOG_LEVEL=INFO\nTORCH_DISTRIBUTED_DEBUG\nTORCH_DISTRIBUTED_DEBUG\nOFF\nINFO\nDETAIL\nDETAIL\nSettingTORCH_DISTRIBUTED_DEBUG=INFOwill result in additional debug logging when models trained withtorch.nn.parallel.DistributedDataParallel()are initialized, andTORCH_DISTRIBUTED_DEBUG=DETAILwill additionally log runtime performance statistics a select number of iterations. These runtime statistics\ninclude data such as forward time, backward time, gradient communication time, etc. As an example, given the following application:\nTORCH_DISTRIBUTED_DEBUG=INFO\ntorch.nn.parallel.DistributedDataParallel()\nTORCH_DISTRIBUTED_DEBUG=DETAIL\n\n```python\nimport os\n\nimport torch\nimport torch.distributed as dist\nimport torch.multiprocessing as mp\n\n\nclass TwoLinLayerNet(torch.nn.Module):\n    def __init__(self):\n        super().__init__()\n        self.a = torch.nn.Linear(10, 10, bias=False)\n        self.b = torch.nn.Linear(10, 1, bias=False)\n\n    def forward(self, x):\n        a = self.a(x)\n        b = self.b(x)\n        return (a, b)\n\n\ndef worker(rank):\n    dist.init_process_group(\"nccl\", rank=rank, world_size=2)\n    torch.cuda.set_device(rank)\n    print(\"init model\")\n    model = TwoLinLayerNet().cuda()\n    print(\"init ddp\")\n    ddp_model = torch.nn.parallel.DistributedDataParallel(model, device_ids=[rank])\n\n    inp = torch.randn(10, 10).cuda()\n    print(\"train\")\n\n    for _ in range(20):\n        output = ddp_model(inp)\n        loss = output[0] + output[1]\n        loss.sum().backward()\n\n\nif __name__ == \"__main__\":\n    os.environ[\"MASTER_ADDR\"] = \"localhost\"\n    os.environ[\"MASTER_PORT\"] = \"29501\"\n    os.environ[\"TORCH_CPP_LOG_LEVEL\"]=\"INFO\"\n    os.environ[\n        \"TORCH_DISTRIBUTED_DEBUG\"\n    ] = \"DETAIL\"  # set to DETAIL for runtime logging.\n    mp.spawn(worker, nprocs=2, args=())\n\n```\n\nThe following logs are rendered at initialization time:\n\n```python\nI0607 16:10:35.739390 515217 logger.cpp:173] [Rank 0]: DDP Initialized with:\nbroadcast_buffers: 1\nbucket_cap_bytes: 26214400\nfind_unused_parameters: 0\ngradient_as_bucket_view: 0\nis_multi_device_module: 0\niteration: 0\nnum_parameter_tensors: 2\noutput_device: 0\nrank: 0\ntotal_parameter_size_bytes: 440\nworld_size: 2\nbackend_name: nccl\nbucket_sizes: 440\ncuda_visible_devices: N/A\ndevice_ids: 0\ndtypes: float\nmaster_addr: localhost\nmaster_port: 29501\nmodule_name: TwoLinLayerNet\nnccl_async_error_handling: N/A\nnccl_blocking_wait: N/A\nnccl_debug: WARN\nnccl_ib_timeout: N/A\nnccl_nthreads: N/A\nnccl_socket_ifname: N/A\ntorch_distributed_debug: INFO\n\n```\n\nThe following logs are rendered during runtime (whenTORCH_DISTRIBUTED_DEBUG=DETAILis set):\nTORCH_DISTRIBUTED_DEBUG=DETAIL\n\n```python\nI0607 16:18:58.085681 544067 logger.cpp:344] [Rank 1 / 2] Training TwoLinLayerNet unused_parameter_size=0\n Avg forward compute time: 40838608\n Avg backward compute time: 5983335\nAvg backward comm. time: 4326421\n Avg backward comm/comp overlap time: 4207652\nI0607 16:18:58.085693 544066 logger.cpp:344] [Rank 0 / 2] Training TwoLinLayerNet unused_parameter_size=0\n Avg forward compute time: 42850427\n Avg backward compute time: 3885553\nAvg backward comm. time: 2357981\n Avg backward comm/comp overlap time: 2234674\n\n```\n\nIn addition,TORCH_DISTRIBUTED_DEBUG=INFOenhances crash logging intorch.nn.parallel.DistributedDataParallel()due to unused parameters in the model. Currently,find_unused_parameters=Truemust be passed intotorch.nn.parallel.DistributedDataParallel()initialization if there are parameters that may be unused in the forward pass, and as of v1.10, all model outputs are required\nto be used in loss computation astorch.nn.parallel.DistributedDataParallel()does not support unused parameters in the backwards pass. These constraints are challenging especially for larger\nmodels, thus when crashing with an error,torch.nn.parallel.DistributedDataParallel()will log the fully qualified name of all parameters that went unused. For example, in the above application,\nif we modifylossto be instead computed asloss=output[1], thenTwoLinLayerNet.adoes not receive a gradient in the backwards pass, and\nthus results inDDPfailing. On a crash, the user is passed information about parameters which went unused, which may be challenging to manually find for large models:\nTORCH_DISTRIBUTED_DEBUG=INFO\ntorch.nn.parallel.DistributedDataParallel()\nfind_unused_parameters=True\ntorch.nn.parallel.DistributedDataParallel()\ntorch.nn.parallel.DistributedDataParallel()\ntorch.nn.parallel.DistributedDataParallel()\nloss\nloss=output[1]\nTwoLinLayerNet.a\nDDP\n\n```python\nRuntimeError: Expected to have finished reduction in the prior iteration before starting a new one. This error indicates that your module has parameters that were not used in producing loss. You can enable unused parameter detection by passing\n the keyword argument `find_unused_parameters=True` to `torch.nn.parallel.DistributedDataParallel`, and by\nmaking sure all `forward` function outputs participate in calculating loss.\nIf you already have done the above, then the distributed data parallel module wasn't able to locate the output tensors in the return value of your module's `forward` function. Please include the loss function and the structure of the return va\nlue of `forward` of your module when reporting this issue (e.g. list, dict, iterable).\nParameters which did not receive grad for rank 0: a.weight\nParameter indices which did not receive grad for rank 0: 0\n\n```\n\nSettingTORCH_DISTRIBUTED_DEBUG=DETAILwill trigger additional consistency and synchronization checks on every collective call issued by the user\neither directly or indirectly (such as DDPallreduce). This is done by creating a wrapper process group that wraps all process groups returned bytorch.distributed.init_process_group()andtorch.distributed.new_group()APIs. As a result, these APIs will return a wrapper process group that can be used exactly like a regular process\ngroup, but performs consistency checks before dispatching the collective to an underlying process group. Currently, these checks include atorch.distributed.monitored_barrier(),\nwhich ensures all ranks complete their outstanding collective calls and reports ranks which are stuck. Next, the collective itself is checked for consistency by\nensuring all collective functions match and are called with consistent tensor shapes. If this is not the case, a detailed error report is included when the\napplication crashes, rather than a hang or uninformative error message. As an example, consider the following function which has mismatched input shapes intotorch.distributed.all_reduce():\nTORCH_DISTRIBUTED_DEBUG=DETAIL\nallreduce\ntorch.distributed.init_process_group()\ntorch.distributed.new_group()\ntorch.distributed.monitored_barrier()\ntorch.distributed.all_reduce()\n\n```python\nimport torch\nimport torch.distributed as dist\nimport torch.multiprocessing as mp\n\n\ndef worker(rank):\n    dist.init_process_group(\"nccl\", rank=rank, world_size=2)\n    torch.cuda.set_device(rank)\n    tensor = torch.randn(10 if rank == 0 else 20).cuda()\n    dist.all_reduce(tensor)\n    torch.cuda.synchronize(device=rank)\n\n\nif __name__ == \"__main__\":\n    os.environ[\"MASTER_ADDR\"] = \"localhost\"\n    os.environ[\"MASTER_PORT\"] = \"29501\"\n    os.environ[\"TORCH_CPP_LOG_LEVEL\"]=\"INFO\"\n    os.environ[\"TORCH_DISTRIBUTED_DEBUG\"] = \"DETAIL\"\n    mp.spawn(worker, nprocs=2, args=())\n\n```\n\nWith theNCCLbackend, such an application would likely result in a hang which can be challenging to root-cause in nontrivial scenarios. If the user enablesTORCH_DISTRIBUTED_DEBUG=DETAILand reruns the application, the following error message reveals the root cause:\nNCCL\nTORCH_DISTRIBUTED_DEBUG=DETAIL\n\n```python\nwork = default_pg.allreduce([tensor], opts)\nRuntimeError: Error when verifying shape tensors for collective ALLREDUCE on rank 0. This likely indicates that input shapes into the collective are mismatched across ranks. Got shapes:  10\n[ torch.LongTensor{1} ]\n\n```\n\nNote\nFor fine-grained control of the debug level during runtime the functionstorch.distributed.set_debug_level(),torch.distributed.set_debug_level_from_env(), andtorch.distributed.get_debug_level()can also be used.\ntorch.distributed.set_debug_level()\ntorch.distributed.set_debug_level_from_env()\ntorch.distributed.get_debug_level()\nIn addition,TORCH_DISTRIBUTED_DEBUG=DETAILcan be used in conjunction withTORCH_SHOW_CPP_STACKTRACES=1to log the entire callstack when a collective desynchronization is detected. These\ncollective desynchronization checks will work for all applications that usec10dcollective calls backed by process groups created with thetorch.distributed.init_process_group()andtorch.distributed.new_group()APIs.\nTORCH_DISTRIBUTED_DEBUG=DETAIL\nTORCH_SHOW_CPP_STACKTRACES=1\nc10d\ntorch.distributed.init_process_group()\ntorch.distributed.new_group()\n\n## Logging#\n\nIn addition to explicit debugging support viatorch.distributed.monitored_barrier()andTORCH_DISTRIBUTED_DEBUG, the underlying C++ library oftorch.distributedalso outputs log\nmessages at various levels. These messages can be helpful to understand the execution state of a distributed training job and to troubleshoot problems such as network connection failures. The\nfollowing matrix shows how the log level can be adjusted via the combination ofTORCH_CPP_LOG_LEVELandTORCH_DISTRIBUTED_DEBUGenvironment variables.\ntorch.distributed.monitored_barrier()\nTORCH_DISTRIBUTED_DEBUG\ntorch.distributed\nTORCH_CPP_LOG_LEVEL\nTORCH_DISTRIBUTED_DEBUG\nTORCH_CPP_LOG_LEVEL\nTORCH_CPP_LOG_LEVEL\nTORCH_DISTRIBUTED_DEBUG\nTORCH_DISTRIBUTED_DEBUG\nEffective Log Level\nERROR\nERROR\nignored\nError\nWARNING\nWARNING\nignored\nWarning\nINFO\nINFO\nignored\nInfo\nINFO\nINFO\nINFO\nINFO\nDebug\nINFO\nINFO\nDETAIL\nDETAIL\nTrace (a.k.a. All)\nDistributed components raise custom Exception types derived fromRuntimeError:\nRuntimeError\ntorch.distributed.DistError: This is the base type of all distributed exceptions.\ntorch.distributed.DistError\ntorch.distributed.DistBackendError: This exception is thrown when a backend-specific error occurs. For example, if\ntheNCCLbackend is used and the user attempts to use a GPU that is not available to theNCCLlibrary.\ntorch.distributed.DistBackendError\nNCCL\nNCCL\ntorch.distributed.DistNetworkError: This exception is thrown when networking\nlibraries encounter errors (ex: Connection reset by peer)\ntorch.distributed.DistNetworkError\ntorch.distributed.DistStoreError: This exception is thrown when the Store encounters\nan error (ex: TCPStore timeout)\ntorch.distributed.DistStoreError\nException raised when an error occurs in the distributed library\nException raised when a backend error occurs in distributed\nException raised when a network error occurs in distributed\nException raised when an error occurs in the distributed store\nIf you are running single node training, it may be convenient to interactively breakpoint your script. We offer a way to conveniently breakpoint a single rank:\nSet a breakpoint, but only on a single rank.  All other ranks will wait for you to be\ndone with the breakpoint before continuing.\nrank(int) \u2013 Which rank to break on.  Default:0\n0\nskip(int) \u2013 Skip the firstskipcalls to this breakpoint. Default:0.\nskip\n0",
  "url": "https://pytorch.org/docs/stable/distributed.html",
  "metadata": {
    "section": null,
    "issue_number": null,
    "labels": null,
    "answer_author": null
  }
}