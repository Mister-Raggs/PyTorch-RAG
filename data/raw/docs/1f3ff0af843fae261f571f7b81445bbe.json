{
  "doc_id": "1f3ff0af843fae261f571f7b81445bbe",
  "source": "pytorch_docs",
  "title": "Elastic Agent \u2014 PyTorch 2.9 documentation",
  "text": "\n## Elastic Agent#\n\nCreated On: May 04, 2021 | Last Updated On: Jun 07, 2025\n\n## Server#\n\nThe elastic agent is the control plane of torchelastic.\nIt is a process that launches and manages underlying worker processes.\nThe agent is responsible for:\nWorking with distributed torch: the workers are started with all the\nnecessary information to successfully and trivially calltorch.distributed.init_process_group().\ntorch.distributed.init_process_group()\nFault tolerance: monitors workers and upon detecting worker failures\nor unhealthiness, tears down all workers and restarts everyone.\nElasticity: Reacts to membership changes and restarts workers with the new\nmembers.\nThe simplest agents are deployed per node and works with local processes.\nA more advanced agent can launch and manage workers remotely. Agents can\nbe completely decentralized, making decisions based on the workers it manages.\nOr can be coordinated, communicating to other agents (that manage workers\nin the same job) to make a collective decision.\nBelow is a diagram of an agent that manages a local group of workers.\n\n## Concepts#\n\nThis section describes the high-level classes and concepts that\nare relevant to understanding the role of theagentin torchelastic.\nagent\nAn agent process responsible for managing one or more worker processes.\nThe worker processes are assumed to be regular distributed PyTorch scripts.\nWhen the worker process is created by the agent, the agent provides the\nnecessary information for the worker processes to properly initialize\na torch process group.\nThe exact deployment topology and ratio of agent-to-worker is dependent\non the specific implementation of the agent and the user\u2019s job placement\npreferences. For instance, to run a distributed training job on GPU with\n8 trainers (one per GPU) one can:\nUse 8 x single GPU instances, place an agent per instance, managing\n1 worker per agent.\nUse 4 x double GPU instances, place an agent per instance, managing\n2 workers per agent.\nUse 2 x quad GPU instances, place an agent per instance, managing\n4 workers per agent.\nUse 1 x 8 GPU instance, place an agent per instance, managing\n8 workers per agent.\nUsage\n\n```python\ngroup_result = agent.run()\n if group_result.is_failed():\n   # workers failed\n   failure = group_result.failures[0]\n   logger.exception(\"worker 0 failed with exit code : %s\", failure.exit_code)\n else:\n   return group_result.return_values[0] # return rank 0's results\n\n```\n\nReturn theWorkerGroupfor the givenrole.\nWorkerGroup\nrole\nNote that the worker group is a mutable object and hence in a\nmulti-threaded/process environment it may change state.\nImplementers are encouraged (but not required) to return\na defensive read-only copy.\nWorkerGroup\nRun the agent.\nSupports retrying the worker group on failures up tomax_restarts.\nmax_restarts\nThe result of the execution, containing the return values or\nfailure details for each worker mapped by the worker\u2019s global rank.\nException - any other failures NOT related to worker process\u2013\nRunResult\nBlueprint information about a particular type of worker.\nFor a given role, there must only exist a single worker spec.\nWorker spec is expected to be homogeneous across all nodes (machine),\nthat is each node runs the same number of workers for a particular spec.\nrole(str) \u2013 user-defined role for the workers with this spec\nlocal_world_size(int) \u2013 number local workers to run\nfn(Optional[Callable]) \u2013 (deprecated use entrypoint instead)\nentrypoint(Optional[Union[Callable,str]]) \u2013 worker function or command\nargs(tuple) \u2013 arguments to pass toentrypoint\nentrypoint\nrdzv_handler(RendezvousHandler) \u2013 handles rdzv for this set of workers\nmax_restarts(int) \u2013 number of max retries for the workers\nmonitor_interval(float) \u2013 monitor status of workers everynseconds\nn\nmaster_port(Optional[int]) \u2013 fixed port to run the c10d store on rank 0\nif not specified then will chose a random free port\nmaster_addr(Optional[str]) \u2013 fixed master_addr to run the c10d store on rank 0\nif not specified then will chose hostname on agent rank 0\nredirects\u2013 redirect std streams to a file,\nselectively redirect for a particular\nlocal rank by passing a map\ntee\u2013 tees the specified std stream(s) to console + file,\nselectively tee for a particular local rank by passing a map,\ntakes precedence overredirectssettings.\nredirects\nevent_log_handler(str) \u2013 name of the event logging handler as registered inelastic/events/handlers.py.\nGet the entry point name.\nIf the entrypoint is a function (e.g.Callable) returns its__qualname__else if the entrypoint is a binary (e.g.str), returns the binary name.\nCallable\n__qualname__\nstr\nA state of theWorkerGroup.\nWorkerGroup\nWorkers in a worker group change state as a unit. If a single worker\nin a worker group fails the entire set is considered failed:\n\n```python\nUNKNOWN - agent lost track of worker group state, unrecoverable\nINIT - worker group object created not yet started\nHEALTHY - workers running and healthy\nUNHEALTHY - workers running and unhealthy\nSTOPPED - workers stopped (interrupted) by the agent\nSUCCEEDED - workers finished running (exit 0)\nFAILED - workers failed to successfully finish (exit !0)\n\n```\n\nA worker group starts from an initialINITstate,\nthen progresses toHEALTHYorUNHEALTHYstates,\nand finally reaches a terminalSUCCEEDEDorFAILEDstate.\nINIT\nHEALTHY\nUNHEALTHY\nSUCCEEDED\nFAILED\nWorker groups can be interrupted and temporarily put intoSTOPPEDstate\nby the agent. Workers inSTOPPEDstate are scheduled to be restarted\nin the near future by the agent. Some examples of workers being put intoSTOPPEDstate are:\nSTOPPED\nSTOPPED\nSTOPPED\nWorker group failure|unhealthy observed\nMembership change detected\nWhen actions (start, stop, rdzv, retry, etc) on worker group fails\nand results in the action being partially applied to the worker group\nthe state will beUNKNOWN. Typically this happens on uncaught/unhandled\nexceptions during state change events on the agent. The agent is not\nexpected to recover worker groups inUNKNOWNstate and is better off\nself terminating and allowing the job manager to retry the node.\nUNKNOWN\nUNKNOWN\nReturn the state of the Worker.\nTrue if the worker state represents workers still running\n(e.g. that the process exists but not necessarily healthy).\nbool\nA worker instance.\nContrast this withWorkerSpecthat represents the specifications of a\nworker. AWorkeris created from aWorkerSpec. AWorkeris to\naWorkerSpecas an object is to a class.\nWorkerSpec\nWorker\nWorkerSpec\nWorker\nWorkerSpec\nTheidof the worker is interpreted\nby the specific implementation ofElasticAgent. For a local\nagent, it could be thepid(int)of the worker, for a remote\nagent it could be encoded ashost:port(string).\nid\nElasticAgent\npid(int)\nhost:port(string)\nid(Any) \u2013 uniquely identifies a worker (interpreted by the agent)\nlocal_rank(int) \u2013 local rank of the worker\nglobal_rank(int) \u2013 global rank of the worker\nrole_rank(int) \u2013 rank of the worker across all workers that have the same role\nworld_size(int) \u2013 number of workers (globally)\nrole_world_size(int) \u2013 number of workers that have the same role\nA set ofWorkerinstances.\nWorker\nThe class defines a set ofWorkerinstances for the givenWorkerSpecmanaged byElasticAgent. Whether the worker\ngroup contains cross instance workers or not depends on the implementation of the agent.\nWorker\nWorkerSpec\nElasticAgent\n\n## Implementations#\n\nBelow are the agent implementations provided by torchelastic.\nAn implementation oftorchelastic.agent.server.ElasticAgentthat handles host-local workers.\ntorchelastic.agent.server.ElasticAgent\nThis agent is deployed per host and is configured to spawnnworkers.\nWhen using GPUs,nmaps to the number of GPUs available on the host.\nn\nn\nThe local agent does not communicate to other local agents deployed on\nother hosts, even if the workers may communicate inter-host. The worker id\nis interpreted to be a local process. The agent starts and stops all worker\nprocesses as a single unit.\nThe worker function and argument passed to the worker function must be\npython multiprocessing compatible. To pass multiprocessing data structures\nto the workers you may create the data structure in the same multiprocessing\ncontext as the specifiedstart_methodand pass it as a function argument.\nstart_method\nTheexit_barrier_timeoutspecifies the amount of time (in seconds) to wait\nfor other agents to finish. This acts as a safety net to handle cases where\nworkers finish at different times, to prevent agents from viewing workers\nthat finished early as a scale-down event. It is strongly advised that the\nuser code deal with ensuring that workers are terminated in a synchronous\nmanner rather than relying on the exit_barrier_timeout.\nexit_barrier_timeout\nA named pipe based watchdog can be enabled in`LocalElasticAgent`if an\nenvironment variableTORCHELASTIC_ENABLE_FILE_TIMERwith value 1 has\nbeen defined in the`LocalElasticAgent`process.\nOptionally, another environment variable`TORCHELASTIC_TIMER_FILE`can be set with a unique file name for the named pipe. If the environment\nvariable`TORCHELASTIC_TIMER_FILE`is not set,`LocalElasticAgent`will internally create a unique file name and set it to the environment\nvariable`TORCHELASTIC_TIMER_FILE`, and this environment variable will\nbe propagated to the worker processes to allow them to connect to the same\nnamed pipe that`LocalElasticAgent`uses.\n`LocalElasticAgent`\nTORCHELASTIC_ENABLE_FILE_TIMER\n`LocalElasticAgent`\n`TORCHELASTIC_TIMER_FILE`\n`TORCHELASTIC_TIMER_FILE`\n`LocalElasticAgent`\n`TORCHELASTIC_TIMER_FILE`\n`LocalElasticAgent`\nLogs are written to the specified log directory. Each log line will be by default\nprefixed by[${role_name}${local_rank}]:(e.g.[trainer0]:foobar).\nLog prefixes can be customized by passing atemplate stringas thelog_line_prefix_templateargument.\nThe following macros (identifiers) are substituted at runtime:${role_name},${local_rank},${rank}. For example, to prefix each log line with\nglobal rank instead of the local rank, setlog_line_prefix_template=\"[${rank}]:.\n[${role_name}${local_rank}]:\n[trainer0]:foobar\nlog_line_prefix_template\n${role_name},${local_rank},${rank}\nlog_line_prefix_template=\"[${rank}]:\nExample launching function\n\n```python\ndef trainer(args) -> str:\n    return \"do train\"\n\ndef main():\n    start_method=\"spawn\"\n    shared_queue= multiprocessing.get_context(start_method).Queue()\n    spec = WorkerSpec(\n                role=\"trainer\",\n                local_world_size=nproc_per_process,\n                entrypoint=trainer,\n                args=(\"foobar\",),\n                ...<OTHER_PARAMS...>)\n    agent = LocalElasticAgent(spec, start_method)\n    results = agent.run()\n\n    if results.is_failed():\n        print(\"trainer failed\")\n    else:\n        print(f\"rank 0 return value: {results.return_values[0]}\")\n        # prints -> rank 0 return value: do train\n\n```\n\nExample launching binary\n\n```python\ndef main():\n    spec = WorkerSpec(\n                role=\"trainer\",\n                local_world_size=nproc_per_process,\n                entrypoint=\"/usr/local/bin/trainer\",\n                args=(\"--trainer-args\", \"foobar\"),\n                ...<OTHER_PARAMS...>)\n    agent = LocalElasticAgent(spec)\n    results = agent.run()\n\n    if not results.is_failed():\n        print(\"binary launches do not have return values\")\n\n```\n\n\n## Extending the Agent#\n\nTo extend the agent you can implementElasticAgentdirectly, however\nwe recommend you extendSimpleElasticAgentinstead, which provides\nmost of the scaffolding and leaves you with a few specific abstract methods\nto implement.\nElasticAgent\nSimpleElasticAgent\nAnElasticAgentthat manages one particular type of worker role.\nElasticAgent\nAnElasticAgentthat manages workers (WorkerGroup) for a singleWorkerSpecsuch as one particular type of worker role.\nElasticAgent\nWorkerGroup\nWorkerSpec\nDetermine proper ranks for worker processes.\nFast Path: when all workers have the same role and world size. We calculate\nthe global rank to be group_rank * group_world_size + local_rank. And therole_world_sizeis the same asglobal_world_size. No TCP store is used in\nthis case. This is only enabled when users set the environment variableTORCH_ELASTIC_WORKER_IDENTICALto 1.\nTime complexity: each worker O(1), overall O(1)\nSlow Path: when workers have different roles and world sizes. We use the\nthe following algorithm:\nEach agent writes its configuration(group_rank, group_world_size\n, num_workers) to the common store.\nThe rank 0 agent reads all the role_info from the store and\ndetermines each agents worker ranks.\nDetermine the global rank: the global rank of the workers is computed\nby cumulative sum of the local_world_size for all workers in front of it.\nFor efficiency reasons each worker is assigned a base global rank\nsuch that it\u2019s workers are in the range [base_global_rank,\nbase_global_rank + local_world_size).\nDetermine the role rank: The role rank is determined using the algorithms\nin the point 3 with the exception that the ranks are calculated with\nrespect to the role name.\nThe rank 0 agent writes the assigned ranks to the store.\nEach agent reads the assigned ranks from the store.\nTime complexity: each worker O(1), rank0 O(n), overall O(n)\nlist[torch.distributed.elastic.agent.server.api.Worker]\nDefine a barrier that keeps the agent process alive until all workers finish.\nWait forexit_barrier_timeoutseconds for all agents to finish\nexecuting their local workers (either successfully or not). This\nacts as a safety guard against user scripts that terminate at different\ntimes.\nexit_barrier_timeout\nStart a fresh set of workers for the worker_group.\nEssentially, a rendezvous followed by astart_workers.\nThe caller should first call_stop_workers()to stop running workers\nprior to calling this method.\nstart_workers\n_stop_workers()\nOptimistically sets the state of the worker group that\njust started asHEALTHYand delegates the actual monitoring\nof state to_monitor_workers()method\nHEALTHY\n_monitor_workers()\nCheck on the workers for theworker_group.\nworker_group\nThis function also returns the new state of the worker group.\nRunResult\nRun rendezvous for the workers specified by the worker spec.\nAssigns workers a new global rank and world size.\nUpdates the rendezvous store for the worker group.\nRestart (stops, rendezvous, starts) all local workers in the group.\nClean up any resources that were allocated during the agent\u2019s work.\ndeath_sig(Signals) \u2013 Signal to send to the child process, SIGTERM is default\nStartworker_group.spec.local_world_sizenumber of workers.\nworker_group.spec.local_world_size\nThis is according to worker spec for the worker group .\nReturns a map oflocal_rankto workerid.\nlocal_rank\nid\ndict[int,Any]\nStop all workers in the given worker group.\nImplementers must deal with workers in all states defined byWorkerState. That is, it must gracefully handle stopping\nnon-existent workers, unhealthy (stuck) workers, etc.\nWorkerState\nReturn results of the worker executions.\nRun results follow an \u201call-or-nothing\u201d policy where the run is successful if and\nonly if ALL local workers managed by this agent complete successfully.\nIf the result is successful (e.g.is_failed()=False) then thereturn_valuesfield contains the outputs (return values) of the workers managed by THIS agent mapped\nby their GLOBAL ranks. That isresult.return_values[0]is the return value of\nglobal rank 0.\nis_failed()=False\nreturn_values\nresult.return_values[0]\nNote\nreturn_valuesare only meaningful for when the worker entrypoint\nis a function. Workers specified as a binary entrypoint do not canonically\nhave a return value and thereturn_valuesfield is meaningless and\nmay be empty.\nreturn_values\nreturn_values\nIfis_failed()returnsTruethen thefailuresfield contains the\nfailure information, again, mapped by the GLOBAL rank of the worker that failed.\nis_failed()\nTrue\nfailures\nThe keys inreturn_valuesandfailuresare mutually exclusive, that is,\na worker\u2019s final state can only be one of: succeeded, failed. Workers intentionally\nterminated by the agent according to the agent\u2019s restart policy, are not represented\nin eitherreturn_valuesnorfailures.\nreturn_values\nfailures\nreturn_values\nfailures\n\n## Watchdog in the Agent#\n\nA named pipe based watchdog can be enabled inLocalElasticAgentif an\nenvironment variableTORCHELASTIC_ENABLE_FILE_TIMERwith value 1 has\nbeen defined in theLocalElasticAgentprocess.\nOptionally, another environment variableTORCHELASTIC_TIMER_FILEcan be set with a unique file name for the named pipe. If the environment\nvariableTORCHELASTIC_TIMER_FILEis not set,LocalElasticAgentwill internally create a unique file name and set it to the environment\nvariableTORCHELASTIC_TIMER_FILE, and this environment variable will\nbe propagated to the worker processes to allow them to connect to the same\nnamed pipe thatLocalElasticAgentuses.\nLocalElasticAgent\nTORCHELASTIC_ENABLE_FILE_TIMER\nLocalElasticAgent\nTORCHELASTIC_TIMER_FILE\nTORCHELASTIC_TIMER_FILE\nLocalElasticAgent\nTORCHELASTIC_TIMER_FILE\nLocalElasticAgent\n\n## Health Check Server#\n\nA health check monitoring server can be enabled inLocalElasticAgentif an environment variableTORCHELASTIC_HEALTH_CHECK_PORThas been defined\nin theLocalElasticAgentprocess.\nAdding interface for health check server which can be extended by starting tcp/http\nserver on the specified port number.\nAdditionally, health check server will have callback to check watchdog is alive.\nLocalElasticAgent\nTORCHELASTIC_HEALTH_CHECK_PORT\nLocalElasticAgent\nInterface for health check monitoring server, which can be extended\nby starting tcp/http server on the specified port.\nalive_callback(Callable[[],int]) \u2013 Callable[[], int], callback to last progress time of agent\nport(int) \u2013 int, port number to start tcp/http server\ntimeout(int) \u2013 int, timeout seconds to decide agent is alive/dead\nUnsupported functionality for Pytorch, doesn\u2019t start any health check server\nFunction to stop health check server\ncreates health check server object\nHealthCheckServer",
  "url": "https://pytorch.org/docs/stable/elastic/agent.html",
  "metadata": {
    "section": null,
    "issue_number": null,
    "labels": null,
    "answer_author": null
  }
}