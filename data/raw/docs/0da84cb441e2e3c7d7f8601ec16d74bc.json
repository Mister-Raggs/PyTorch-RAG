{
  "doc_id": "0da84cb441e2e3c7d7f8601ec16d74bc",
  "source": "pytorch_docs",
  "title": "torch.export-based ONNX Exporter \u2014 PyTorch 2.9 documentation",
  "text": "\n## torch.export-based ONNX Exporter#\n\nCreated On: Jun 10, 2025 | Last Updated On: Aug 22, 2025\nOverview\nDependencies\nA simple example\nInspecting the ONNX model using GUI\nWhen the conversion fails\nMetadata\nAPI Reference\n\n## Overview#\n\ntorch.exportengine is leveraged to produce a traced graph representing only the Tensor computation of the function in an\nAhead-of-Time (AOT) fashion. The resulting traced graph (1) produces normalized operators in the functional\nATen operator set (as well as any user-specified custom operators), (2) has eliminated all Python control\nflow and data structures (with certain exceptions), and (3) records the set of shape constraints needed to\nshow that this normalization and control-flow elimination is sound for future inputs, before it is finally\ntranslated into an ONNX graph.\nIn addition, during the export process, memory usage is significantly reduced.\n\n## Dependencies#\n\nThe ONNX exporter depends on extra Python packages:\nONNX\nONNX Script\nThey can be installed throughpip:\n\n```python\n  pip install --upgrade onnx onnxscript\n\n```\n\nonnxruntimecan then be used to execute the model\non a large variety of processors.\n\n## A simple example#\n\nSee below a demonstration of exporter API in action with a simple Multilayer Perceptron (MLP) as example:\n\n```python\nimport torch\nimport torch.nn as nn\n\nclass MLPModel(nn.Module):\n  def __init__(self):\n      super().__init__()\n      self.fc0 = nn.Linear(8, 8, bias=True)\n      self.fc1 = nn.Linear(8, 4, bias=True)\n      self.fc2 = nn.Linear(4, 2, bias=True)\n      self.fc3 = nn.Linear(2, 2, bias=True)\n      self.fc_combined = nn.Linear(8 + 8 + 8, 8, bias=True)  # Combine all inputs\n\n  def forward(self, tensor_x: torch.Tensor, input_dict: dict, input_list: list):\n      \"\"\"\n      Forward method that requires all inputs:\n      - tensor_x: A direct tensor input.\n      - input_dict: A dictionary containing the tensor under the key 'tensor_x'.\n      - input_list: A list where the first element is the tensor.\n      \"\"\"\n      # Extract tensors from inputs\n      dict_tensor = input_dict['tensor_x']\n      list_tensor = input_list[0]\n\n      # Combine all inputs into a single tensor\n      combined_tensor = torch.cat([tensor_x, dict_tensor, list_tensor], dim=1)\n\n      # Process the combined tensor through the layers\n      combined_tensor = self.fc_combined(combined_tensor)\n      combined_tensor = torch.sigmoid(combined_tensor)\n      combined_tensor = self.fc0(combined_tensor)\n      combined_tensor = torch.sigmoid(combined_tensor)\n      combined_tensor = self.fc1(combined_tensor)\n      combined_tensor = torch.sigmoid(combined_tensor)\n      combined_tensor = self.fc2(combined_tensor)\n      combined_tensor = torch.sigmoid(combined_tensor)\n      output = self.fc3(combined_tensor)\n      return output\n\nmodel = MLPModel()\n\n# Example inputs\ntensor_input = torch.rand((97, 8), dtype=torch.float32)\ndict_input = {'tensor_x': torch.rand((97, 8), dtype=torch.float32)}\nlist_input = [torch.rand((97, 8), dtype=torch.float32)]\n\n# The input_names and output_names are used to identify the inputs and outputs of the ONNX model\ninput_names = ['tensor_input', 'tensor_x', 'list_input_index_0']\noutput_names = ['output']\n\n# Exporting the model with all required inputs\nonnx_program = torch.onnx.export(model,(tensor_input, dict_input, list_input), dynamic_shapes=({0: \"batch_size\"},{\"tensor_x\": {0: \"batch_size\"}},[{0: \"batch_size\"}]), input_names=input_names, output_names=output_names, dynamo=True,)\n\n# Check the exported ONNX model is dynamic\nassert onnx_program.model.graph.inputs[0].shape == (\"batch_size\", 8)\nassert onnx_program.model.graph.inputs[1].shape == (\"batch_size\", 8)\nassert onnx_program.model.graph.inputs[2].shape == (\"batch_size\", 8)\n\n```\n\nAs the code above shows, all you need is to providetorch.onnx.export()with an instance of the model and its input.\nThe exporter will then return an instance oftorch.onnx.ONNXProgramthat contains the exported ONNX graph along with extra information.\ntorch.onnx.export()\ntorch.onnx.ONNXProgram\nThe in-memory model available throughonnx_program.model_protois anonnx.ModelProtoobject in compliance with theONNX IR spec.\nThe ONNX model may then be serialized into aProtobuf fileusing thetorch.onnx.ONNXProgram.save()API.\nonnx_program.model_proto\nonnx.ModelProto\ntorch.onnx.ONNXProgram.save()\n\n```python\n  onnx_program.save(\"mlp.onnx\")\n\n```\n\n\n## Inspecting the ONNX model using GUI#\n\nYou can view the exported model usingNetron.\n\n## When the conversion fails#\n\nFunctiontorch.onnx.export()should be called a second time with\nparameterreport=True. A markdown report is generated to help the user\nto resolve the issue.\ntorch.onnx.export()\nreport=True\n\n## Metadata#\n\nDuring ONNX export, each ONNX node is annotated with metadata that helps trace its origin and context from the original PyTorch model. This metadata is useful for debugging, model inspection, and understanding the mapping between PyTorch and ONNX graphs.\nThe following metadata fields are added to each ONNX node:\nnamespace\nA string representing the hierarchical namespace of the node, consisting of a stack trace of modules/methods.\nExample:__main__.SimpleAddModel/add:aten.add.Tensor\n__main__.SimpleAddModel/add:aten.add.Tensor\npkg.torch.onnx.class_hierarchy\nA list of class names representing the hierarchy of modules leading to this node.\nExample:['__main__.SimpleAddModel','aten.add.Tensor']\n['__main__.SimpleAddModel','aten.add.Tensor']\npkg.torch.onnx.fx_node\nThe string representation of the original FX node, including its name, number of consumers, the targeted torch op, arguments, and keyword arguments.\nExample:%cat:[num_users=1]=call_function[target=torch.ops.aten.cat.default](args=([%tensor_x,%input_dict_tensor_x,%input_list_0],1),kwargs={})\n%cat:[num_users=1]=call_function[target=torch.ops.aten.cat.default](args=([%tensor_x,%input_dict_tensor_x,%input_list_0],1),kwargs={})\npkg.torch.onnx.name_scopes\nA list of name scopes (methods) representing the path to this node in the PyTorch model.\nExample:['','add']\n['','add']\npkg.torch.onnx.stack_trace\nThe stack trace from the original code where this node was created, if available.\nExample:\n\n```python\nFile \"simpleadd.py\", line 7, in forward\n    return torch.add(x, y)\n\n```\n\nThese metadata fields are stored in the metadata_props attribute of each ONNX node and can be inspected using Netron or programmatically.\nThe overall ONNX graph has the followingmetadata_props:\nmetadata_props\npkg.torch.export.ExportedProgram.graph_signature\nThis property contains a string representation of the graph_signature from the original PyTorch ExportedProgram. The graph signature describes the structure of the model\u2019s inputs and outputs and how they map to the ONNX graph. The inputs are defined asInputSpecobjects, which include the kind of input (e.g.,InputKind.PARAMETERfor parameters,InputKind.USER_INPUTfor user-defined inputs), the argument name, the target (which can be a specific node in the model), and whether the input is persistent. The outputs are defined asOutputSpecobjects, which specify the kind of output (e.g.,OutputKind.USER_OUTPUT) and the argument name.\nInputSpec\nInputKind.PARAMETER\nInputKind.USER_INPUT\nOutputSpec\nOutputKind.USER_OUTPUT\nTo read more about the graph signature, please see thetorch.exportfor more information.\npkg.torch.export.ExportedProgram.range_constraints\nThis property contains a string representation of any range constraints that were present in the original PyTorch ExportedProgram. Range constraints specify valid ranges for symbolic shapes or values in the model, which can be important for models that use dynamic shapes or symbolic dimensions.\nExample:s0:VR[2,int_oo], which indicates that the size of the input tensor must be at least 2.\ns0:VR[2,int_oo]\nTo read more about range constraints, please see thetorch.exportfor more information.\nEach input value in the ONNX graph may have the following metadata property:\npkg.torch.export.graph_signature.InputSpec.kind\nThe kind of input, as defined by PyTorch\u2019s InputKind enum.\nExample values:\n\u201cUSER_INPUT\u201d: A user-provided input to the model.\n\u201cPARAMETER\u201d: A model parameter (e.g., weight).\n\u201cBUFFER\u201d: A model buffer (e.g., running mean in BatchNorm).\n\u201cCONSTANT_TENSOR\u201d: A constant tensor argument.\n\u201cCUSTOM_OBJ\u201d: A custom object input.\n\u201cTOKEN\u201d: A token input.\npkg.torch.export.graph_signature.InputSpec.persistent\nIndicates whether the input is persistent (i.e., should be saved as part of the model\u2019s state).\nExample values:\n\u201cTrue\u201d\n\u201cFalse\u201d\nEach output value in the ONNX graph may have the following metadata property:\npkg.torch.export.graph_signature.OutputSpec.kind\nThe kind of input, as defined by PyTorch\u2019s OutputKind enum.\nExample values:\n\u201cUSER_OUTPUT\u201d: A user-visible output.\n\u201cLOSS_OUTPUT\u201d: A loss value output.\n\u201cBUFFER_MUTATION\u201d: Indicates a buffer was mutated.\n\u201cGRADIENT_TO_PARAMETER\u201d: Gradient output for a parameter.\n\u201cGRADIENT_TO_USER_INPUT\u201d: Gradient output for a user input.\n\u201cUSER_INPUT_MUTATION\u201d: Indicates a user input was mutated.\n\u201cTOKEN\u201d: A token output.\nEach initialized value, input, output has the following metadata:\npkg.torch.onnx.original_node_name\nThe original name of the node in the PyTorch FX graph that produced this value in the case where the value was renamed. This helps trace initializers back to their source in the original model.\nExample:fc1.weight\nfc1.weight\n\n## API Reference#\n\nExports a model into ONNX format.\nSettingdynamo=Trueenables the new ONNX export logic\nwhich is based ontorch.export.ExportedProgramand a more modern\nset of translation logic. This is the recommended and default way to export models\nto ONNX.\ndynamo=True\ntorch.export.ExportedProgram\nWhendynamo=True:\ndynamo=True\nThe exporter tries the following strategies to get an ExportedProgram for conversion to ONNX.\nIf the model is already an ExportedProgram, it will be used as-is.\nUsetorch.export.export()and setstrict=False.\ntorch.export.export()\nstrict=False\nUsetorch.export.export()and setstrict=True.\ntorch.export.export()\nstrict=True\nmodel(torch.nn.Module|torch.export.ExportedProgram|torch.jit.ScriptModule|torch.jit.ScriptFunction) \u2013 The model to be exported.\nargs(tuple[Any,...]) \u2013 Example positional inputs. Any non-Tensor arguments will be hard-coded into the\nexported model; any Tensor arguments will become inputs of the exported model,\nin the order they occur in the tuple.\nf(str|os.PathLike|None) \u2013 Path to the output ONNX model file. E.g. \u201cmodel.onnx\u201d. This argument is kept for\nbackward compatibility. It is recommended to leave unspecified (None)\nand use the returnedtorch.onnx.ONNXProgramto serialize the model\nto a file instead.\ntorch.onnx.ONNXProgram\nkwargs(dict[str,Any]|None) \u2013 Optional example keyword inputs.\nverbose(bool|None) \u2013 Whether to enable verbose logging.\ninput_names(Sequence[str]|None) \u2013 names to assign to the input nodes of the graph, in order.\noutput_names(Sequence[str]|None) \u2013 names to assign to the output nodes of the graph, in order.\nopset_version(int|None) \u2013 The version of thedefault (ai.onnx) opsetto target. You should setopset_versionaccording to the supported opset versions\nof the runtime backend or compiler you want to run the exported model with.\nLeave as default (None) to use the recommended version, or refer to\nthe ONNX operators documentation for more information.\nopset_version\nNone\ndynamo(bool) \u2013 Whether to export the model withtorch.exportExportedProgram instead of TorchScript.\ntorch.export\nexternal_data(bool) \u2013 Whether to save the model weights as an external data file.\nThis is required for models with large weights that exceed the ONNX file size limit (2GB).\nWhen False, the weights are saved in the ONNX file with the model architecture.\ndynamic_shapes(dict[str,Any]|tuple[Any,...]|list[Any]|None) \u2013 A dictionary or a tuple of dynamic shapes for the model inputs. Refer totorch.export.export()for more details. This is only used (and preferred) when dynamo is True.\nNote that dynamic_shapes is designed to be used when the model is exported with dynamo=True, while\ndynamic_axes is used when dynamo=False.\ntorch.export.export()\ncustom_translation_table(dict[Callable,Callable|Sequence[Callable]]|None) \u2013 A dictionary of custom decompositions for operators in the model.\nThe dictionary should have the callable target in the fx Node as the key (e.g.torch.ops.aten.stft.default),\nand the value should be a function that builds that graph using ONNX Script. This option\nis only valid when dynamo is True.\ntorch.ops.aten.stft.default\nreport(bool) \u2013 Whether to generate a markdown report for the export process. This option\nis only valid when dynamo is True.\noptimize(bool) \u2013 Whether to optimize the exported model. This option\nis only valid when dynamo is True. Default is True.\nverify(bool) \u2013 Whether to verify the exported model using ONNX Runtime. This option\nis only valid when dynamo is True.\nprofile(bool) \u2013 Whether to profile the export process. This option\nis only valid when dynamo is True.\ndump_exported_program(bool) \u2013 Whether to dump thetorch.export.ExportedProgramto a file.\nThis is useful for debugging the exporter. This option is only valid when dynamo is True.\ntorch.export.ExportedProgram\nartifacts_dir(str|os.PathLike) \u2013 The directory to save the debugging artifacts like the report and the serialized\nexported program. This option is only valid when dynamo is True.\nfallback(bool) \u2013 Whether to fallback to the TorchScript exporter if the dynamo exporter fails.\nThis option is only valid when dynamo is True. When fallback is enabled, It is\nrecommended to set dynamic_axes even when dynamic_shapes is provided.\nexport_params(bool) \u2013When ``f`` is specified: If false, parameters (weights) will not be exported.You can also leave it unspecified and use the returnedtorch.onnx.ONNXProgramto control how initializers are treated when serializing the model.\nWhen ``f`` is specified: If false, parameters (weights) will not be exported.\nYou can also leave it unspecified and use the returnedtorch.onnx.ONNXProgramto control how initializers are treated when serializing the model.\ntorch.onnx.ONNXProgram\nkeep_initializers_as_inputs(bool) \u2013When ``f`` is specified: If True, all the\ninitializers (typically corresponding to model weights) in the\nexported graph will also be added as inputs to the graph. If False,\nthen initializers are not added as inputs to the graph, and only\nthe user inputs are added as inputs.Set this to True if you intend to supply model weights at runtime.\nSet it to False if the weights are static to allow for better optimizations\n(e.g. constant folding) by backends/runtimes.You can also leave it unspecified and use the returnedtorch.onnx.ONNXProgramto control how initializers are treated when serializing the model.\nWhen ``f`` is specified: If True, all the\ninitializers (typically corresponding to model weights) in the\nexported graph will also be added as inputs to the graph. If False,\nthen initializers are not added as inputs to the graph, and only\nthe user inputs are added as inputs.\nSet this to True if you intend to supply model weights at runtime.\nSet it to False if the weights are static to allow for better optimizations\n(e.g. constant folding) by backends/runtimes.\nYou can also leave it unspecified and use the returnedtorch.onnx.ONNXProgramto control how initializers are treated when serializing the model.\ntorch.onnx.ONNXProgram\ndynamic_axes(Mapping[str,Mapping[int,str]]|Mapping[str,Sequence[int]]|None) \u2013Prefer specifyingdynamic_shapeswhendynamo=Trueand whenfallbackis not enabled.By default the exported model will have the shapes of all input and output tensors\nset to exactly match those given inargs. To specify axes of tensors as\ndynamic (i.e. known only at run-time), setdynamic_axesto a dict with schema:KEY (str): an input or output name. Each name must also be provided ininput_namesoroutput_names.VALUE (dict or list): If a dict, keys are axis indices and values are axis names. If alist, each element is an axis index.For example:classSumModule(torch.nn.Module):defforward(self,x):returntorch.sum(x,dim=1)torch.onnx.export(SumModule(),(torch.ones(2,2),),\"onnx.pb\",input_names=[\"x\"],output_names=[\"sum\"],)Produces:input{name:\"x\"...shape{dim{dim_value:2# axis 0}dim{dim_value:2# axis 1...output{name:\"sum\"...shape{dim{dim_value:2# axis 0...While:torch.onnx.export(SumModule(),(torch.ones(2,2),),\"onnx.pb\",input_names=[\"x\"],output_names=[\"sum\"],dynamic_axes={# dict value: manually named axes\"x\":{0:\"my_custom_axis_name\"},# list value: automatic names\"sum\":[0],},)Produces:input{name:\"x\"...shape{dim{dim_param:\"my_custom_axis_name\"# axis 0}dim{dim_value:2# axis 1...output{name:\"sum\"...shape{dim{dim_param:\"sum_dynamic_axes_1\"# axis 0...\nPrefer specifyingdynamic_shapeswhendynamo=Trueand whenfallbackis not enabled.\ndynamic_shapes\ndynamo=True\nfallback\nBy default the exported model will have the shapes of all input and output tensors\nset to exactly match those given inargs. To specify axes of tensors as\ndynamic (i.e. known only at run-time), setdynamic_axesto a dict with schema:\nargs\ndynamic_axes\ninput_names\noutput_names.\noutput_names\nlist, each element is an axis index.\nFor example:\n\n```python\nclass SumModule(torch.nn.Module):\n    def forward(self, x):\n        return torch.sum(x, dim=1)\n\n\ntorch.onnx.export(\n    SumModule(),\n    (torch.ones(2, 2),),\n    \"onnx.pb\",\n    input_names=[\"x\"],\n    output_names=[\"sum\"],\n)\n\n```\n\nProduces:\n\n```python\ninput {\n  name: \"x\"\n  ...\n      shape {\n        dim {\n          dim_value: 2  # axis 0\n        }\n        dim {\n          dim_value: 2  # axis 1\n...\noutput {\n  name: \"sum\"\n  ...\n      shape {\n        dim {\n          dim_value: 2  # axis 0\n...\n\n```\n\nWhile:\n\n```python\ntorch.onnx.export(\n    SumModule(),\n    (torch.ones(2, 2),),\n    \"onnx.pb\",\n    input_names=[\"x\"],\n    output_names=[\"sum\"],\n    dynamic_axes={\n        # dict value: manually named axes\n        \"x\": {0: \"my_custom_axis_name\"},\n        # list value: automatic names\n        \"sum\": [0],\n    },\n)\n\n```\n\nProduces:\n\n```python\ninput {\n  name: \"x\"\n  ...\n      shape {\n        dim {\n          dim_param: \"my_custom_axis_name\"  # axis 0\n        }\n        dim {\n          dim_value: 2  # axis 1\n...\noutput {\n  name: \"sum\"\n  ...\n      shape {\n        dim {\n          dim_param: \"sum_dynamic_axes_1\"  # axis 0\n...\n\n```\n\ntraining(_C_onnx.TrainingMode) \u2013 Deprecated option. Instead, set the training mode of the model before exporting.\noperator_export_type(_C_onnx.OperatorExportTypes) \u2013 Deprecated option. Only ONNX is supported.\ndo_constant_folding(bool) \u2013 Deprecated option.\ncustom_opsets(Mapping[str,int]|None) \u2013 Deprecated option.\nexport_modules_as_functions(bool|Collection[type[torch.nn.Module]]) \u2013 Deprecated option.\nautograd_inlining(bool) \u2013 Deprecated option.\ntorch.onnx.ONNXProgramif dynamo is True, otherwise None.\ntorch.onnx.ONNXProgram\nONNXProgram| None\nChanged in version 2.6:trainingis now deprecated. Instead, set the training mode of the model before exporting.operator_export_typeis now deprecated. Only ONNX is supported.do_constant_foldingis now deprecated. It is always enabled.export_modules_as_functionsis now deprecated.autograd_inliningis now deprecated.\nChanged in version 2.7:optimizeis now True by default.\nChanged in version 2.9:dynamois now True by default.\nA class to represent an ONNX program that is callable with torch tensors.\nmodel\u2013 The ONNX model as an ONNX IR model object.\nexported_program\u2013 The exported program that produced the ONNX model.\nApply the weights from the specified state dict to the ONNX model.\nUse this method to replace FakeTensors or other weights.\nstate_dict(dict[str,torch.Tensor]) \u2013 The state dict containing the weights to apply to the ONNX model.\nRun the ONNX model using the reference backend.\nSequence[Tensor]\nCompute the values of the specified names in the ONNX model.\nThis method is used to compute the values of the specified names in the ONNX model.\nThe values are returned as a dictionary mapping names to tensors.\nvalue_names(Sequence[str]) \u2013 The names of the values to compute.\nA dictionary mapping names to tensors.\nSequence[Tensor]\nInitialize the ONNX Runtime inference session.\ninitializer(Callable[[str|bytes],ort.InferenceSession]) \u2013 The function to initialize the ONNX Runtime inference\nsession with the specified model. By default, it uses the_ort_session_initializer()function.\n_ort_session_initializer()\nReturn the ONNXModelProtoobject.\nModelProto\nOptimize the ONNX model.\nThis method optimizes the ONNX model by performing constant folding and\neliminating redundancies in the graph. The optimization is done in-place.\nRelease the inference session.\nYou may call this method to release the resources used by the inference session.\nSave the ONNX model to the specified destination.\nWhenexternal_dataisTrueor the model is larger than 2GB,\nthe weights are saved as external data in a separate file.\nexternal_data\nTrue\nInitializer (model weights) serialization behaviors:\ninclude_initializers=True,keep_initializers_as_inputs=False(default):\nThe initializers are included in the saved model.\ninclude_initializers=True\nkeep_initializers_as_inputs=False\ninclude_initializers=True,keep_initializers_as_inputs=True:\nThe initializers are included in the saved model and kept as model inputs.\nChoose this option if you want the ability to override the model weights\nduring inference.\ninclude_initializers=True\nkeep_initializers_as_inputs=True\ninclude_initializers=False,keep_initializers_as_inputs=False:\nThe initializers are not included in the saved model and are not listed\nas model inputs. Choose this option if you want to attach the initializers\nto the ONNX model in a separate, post-processing, step.\ninclude_initializers=False\nkeep_initializers_as_inputs=False\ninclude_initializers=False,keep_initializers_as_inputs=True:\nThe initializers are not included in the saved model but are listed as model\ninputs. Choose this option if you want to supply the initializers during\ninference and want to minimize the size of the saved model.\ninclude_initializers=False\nkeep_initializers_as_inputs=True\ndestination(str|os.PathLike) \u2013 The path to save the ONNX model to.\ninclude_initializers(bool) \u2013 Whether to include the initializers in the saved model.\nkeep_initializers_as_inputs(bool) \u2013 Whether to keep the initializers as inputs in the saved model.\nIfTrue, the initializers are added as inputs to the model which means they can be overwritten.\nby providing the initializers as model inputs.\nexternal_data(Optional[bool]) \u2013 Whether to save the weights as external data in a separate file.\nTypeError\u2013 Ifexternal_dataisTrueanddestinationis not a file path.\nexternal_data\nTrue\ndestination\nReturns whether it is in the middle of ONNX export.\nbool\nErrors raised by the ONNX exporter. This is the base class for all exporter errors.",
  "url": "https://pytorch.org/docs/stable/onnx_export.html",
  "metadata": {
    "section": null,
    "issue_number": null,
    "labels": null,
    "answer_author": null
  }
}