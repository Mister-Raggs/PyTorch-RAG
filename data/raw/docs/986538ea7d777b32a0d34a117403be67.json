{
  "doc_id": "986538ea7d777b32a0d34a117403be67",
  "source": "pytorch_docs",
  "title": "TunableOp \u2014 PyTorch 2.9 documentation",
  "text": "\n## TunableOp#\n\nCreated On: Jun 03, 2024 | Last Updated On: Jun 13, 2025\n\n## Overview#\n\nThis module exposes a TunableOp interface.\nSome operations, such as GEMMs, could be implemented using more than one library\nor more than one technique. For example, a GEMM could be implemented for CUDA or\nROCm using either the blas or blasLt libraries. Further, ROCm\u2019s rocblas and\nhipblaslt libraries allow the user to query for all possible algorithms and then\nchoose one. How does one know which implementation is the fastest and should be\nchosen? That\u2019s what TunableOp provides.\n\n## Enabling TunableOp and Tuning Separately#\n\nThe TunableOp feature is enabled separately from enabling the tuning phase\nitself. Enabling TunableOp means that PyTorch will replace any standard\noperators with their Tunable implementations. Any call to a TunableOp first\nchecks whether it has already been tuned for the given operator inputs. If so,\nit will immediately call the tuned operation; no further tuning will take place\neven when the tuning setting is enabled. Instead if no tuning result is found,\nand tuning is enabled, the TunableOp will benchmark every registered\nimplementation of that operator for the given set of inputs and select the\nfastest.\n\n## File Input and Output#\n\nThe first time any TunableOp is invoked, the internal database of tuned\noperations will be prepared by attempting to read the results from the given\nfile. The default filename is \u2018tunableop_results.csv\u2019. To support tuning when\nmultiple GPUs are used across multiple processes, the GPU device ordinal is\nautomatically inserted into the filename to avoid multiple processes overwriting\nthe same file.\nIf tuning is enabled and new tunings are discovered during the course of your\nworkload, it will also write out to this same filename with all tunings, both\nthe ones it read in at startup as well as the new ones found at runtime. This\ncan be used, for example, to build up a tunings file across many workloads by\nreusing the same file. The output file is automatically created when the\napplication terminates. This behavior can be controlled by the C++ and Python\nAPIs but not the environment variables.\nAssuming you specified a filename, you\u2019ll end up with a CSV file with contents\nlike so:\n\n```python\nValidator,PT_VERSION,2.2.0\nValidator,ROCM_VERSION,6.0.0.0-12969-1544e39\nValidator,HIPBLASLT_VERSION,0.6.0-a9c5cc7\nValidator,ROCBLAS_VERSION,4.0.0-72e57364-dirty\nGemmTunableOp_float_NT,nt_25088_4096_64,Gemm_Hipblaslt_1219,1.262\nGemmTunableOp_float_NT,nt_4096_4096_64,Gemm_Rocblas_1216,0.033\n\n```\n\nNote the \u201cValidator\u201d lines. If you change a library version, or ROCm version, or\nPyTorch version, TunableOp will detect this and reject the tunings file because\nthe prior tunings are likely affected by other software changes.\nThe remaining lines are the tuned solutions for each TunableOp encountered\nduring your execution. Each line consists of 4 comma-separated fields: operator\nname, operator parameters, solution name, and average execution time. The\nexecution time is an optional field. The CSV file can be edited, but with\ncaution. For example, the solution name (field 3) can be changed to \u201cDefault\u201d\nand it will fall back to the original PyTorch untuned implementation. Or, in the\ncase of ROCm\u2019s hipBLAS or hipBLASLt libraries, if you know the specific solution\nindex you can override the solution that TunableOp selected by replacing the\nvalue. The operator name and parameters (fields 1 and 2) are internally named\nand should not be modified. In the case of GemmTunableOp, field 1 indicates the\ndatatype and whether the inputs are transposed (T) or not (N) and field 2\nindicates the M, N, K input shapes.\nThere is an option to enable verbose output but it is only recommended for\ndebugging purposes. This will produce a lot of diagnostic messages but may be\nuseful to see if TunableOp is being used at all. Otherwise, TunableOp is\ncompletely silent, besides file output, unless there is a warning or error\nduring its use. The verbose option is only available by setting the environment\nvariable PYTORCH_TUNABLEOP_VEROBSE=1.\n\n## A Note on Tuning Behavior, Warmup, and Cache Effects#\n\nTuning an operator consists of iterating through the list or registered\nimplementations and profiling each one. The profile is established by running a\nsingle implementation in a loop multiple times and taking the average execution\ntime. There is also an optional warmup phase prior to tuning that can help with\nreaching stable power states by the hardware. During tuning of a workload the\nvarious hardware caches will more likely produce hits than when not tuning.\nThere are options for flushing the instruction cache and rotate the input tensors\nwhich might help produce a more faithful profile of the tuned operator as if the\noperator were run within a larger workload instead of in a tight, repetitive loop.\nBy default, each possible solution for a given operator will be run for either\n100 iterations or as many iterations that can be run within 30ms, whichever is\nsmaller, and its average execution will be calculated. The fastest solution\namong all that were successfully profiled will be chosen. A profile might fail\nif the given solution doesn\u2019t achieve the same accuracy as the default\nimplementation or if the solution returns an error code.\n\n## Current Tunable Operators#\n\nCurrently only a TunableGemm for ROCm is implemented. Note that CUDA builds of\nPyTorch will function correctly when using TunableOp but the only solution\navailable to CUDA builds is the \u2018Default\u2019 implementation i.e. the original\ncuBLAS default, now called through TunableOp. Any call to at::cuda::blas::gemm()\nor ::bgemm() will be routed through TunableOp when enabled. Calling gemm() for a\ngiven set of input arguments (transa, transb, m, n, k) will attempt to use the\nfastest available implementation across both rocblas and hipblaslt.\n\n## Offline Tuning#\n\nThere are several use cases for offline tuning.\nOne use case involves a workload with a high-memory utilization, where regular tuning might lead to running out of memory.\nAnother use case is for compute-intensive workloads. In such cases, it is more resource-efficient to collect\nthe GEMMs for the workload once and then tune repeatedly with different tuning parameters or libraries.\nThere are basically two steps:\n1) Set the environment variables to collect the untuned GEMM and this will generatetunableop_untuned0.csv:\ntunableop_untuned0.csv\n\n```python\nexport PYTORCH_TUNABLEOP_ENABLED=1\nexport PYTORCH_TUNABLEOP_TUNING=0\nexport PYTORCH_TUNABLEOP_RECORD_UNTUNED=1\n...\n\n```\n\nRun a Python script that reads thetunableop_untuned0.csvand generates thetunableop_results0.csv, like this:\ntunableop_untuned0.csv\ntunableop_results0.csv\n\n```python\nimport torch.cuda.tunable as tunable\nimport os\n\nos.putenv(\"PYTORCH_TUNABLEOP_ENABLED\", \"1\")\nos.putenv(\"PYTORCH_TUNABLEOP_TUNING\", \"1\")\nos.putenv(\"PYTORCH_TUNABLEOP_RECORD_UNTUNED\", \"0\")\ntunable.tune_gemm_in_file(\"tunableop_untuned0.csv\")\n\n```\n\nIt is also possible to take multiple untuned files and distribute the GEMMs for tuning to multiple GPUs\nwithin a single node. In the first step, the GEMMs are first gathered and duplicate GEMMs are eliminated.\nNext, the GEMMs are distributed to different GPUs for tuning. After all GEMMs are tuned, the results from\nall the GPUs are then gathered into a single file whose base filename has_full0appended to it\n(for exampletunableop_results_full0.csv). Finally, this new file, containing the gathered results, will be\nduplicated N times, once for each GPU as convenience to the user will run the workload with the tuned\nconfiguration on N GPUs.\n_full0\ntunableop_results_full0.csv\n\n```python\nif __name__ == \"__main__\":\n    num_gpus = 8  # number of GPUs that will be used during the tuning process\n    tunable.mgpu_tune_gemm_in_file(\"tunableop_untuned?.csv\", num_gpus)\n\n```\n\nNote that the usage of themgpu_tune_gemm_in_fileAPI is different from its single GPU counterpart\n(tune_gemm_in_file). The body of the Python script that calls the API must be wrapped inmain()as shown\ndue to the use of concurrent futures module. The argument tomgpu_tune_gemm_in_filemust contain a wild card\nexpression (?or*) to generate the list of untuned files containing the GEMMs to be processed. Thenum_gpusmust between 1 and the total number of GPUs available.\nmgpu_tune_gemm_in_file\ntune_gemm_in_file\nmain()\nmgpu_tune_gemm_in_file\n?\n*\nnum_gpus\n\n## Tuning Context#\n\nThe behavior of TunableOp is currently manipulated through environment\nvariables, the C++ interface of at::cuda::tunable::getTuningContext(), or the\ntorch.cuda.tunable python interfaces. The environment variables take precedence\nover any setting you manipulate using the C++ or Python APIs.\nEnvironment variables are cached the first time they are read. You cannot use the\nenvironment variable interface programmatically since the settings become fixed.\nUse the C++ or Python APIs instead.\n\n## API Reference#\n\nThis is the big on/off switch for all TunableOp implementations.\nReturns whether the TunableOp feature is enabled.\nbool\nEnable tuning of TunableOp implementations.\nWhen enabled, if a tuned entry isn\u2019t found, run the tuning step and record\nthe entry.\nReturns whether TunableOp implementations can be tuned.\nbool\nEnable recording untuned of TunableOp perations for offline tuning.\nWhen enabled, if a tuned entry isn\u2019t found, write it to the untuned file.\nReturns whether TunableOp operations are recorded for offline tuning.\nbool\nSet max time in milliseconds to spend tuning a given solution.\nIf both max tuning duration and iterations are set, the smaller of the two\nwill be honored. At minimum 1 tuning iteration will always be run.\nGet max time to spend tuning a given solution.\nint\nSet max number of iterations to spend tuning a given solution.\nIf both max tuning duration and iterations are set, the smaller of the two\nwill be honored. At minimum 1 tuning iteration will always be run.\nGet max iterations to spend tuning a given solution.\nint\nSet the filename to use for input/output of tuning results.\nIfinsert_device_ordinalisTruethen the current device ordinal\nwill be added to the given filename automatically. This can be used in a\n1-process-per-gpu scenario to ensure all processes write to a separate file.\ninsert_device_ordinal\nTrue\nGet the results filename.\nstr\nReturn all TunableOp results.\ntuple[str,str,str,float]\nReturn the TunableOp validators.\ntuple[str,str]\nDuring Tuning Context destruction, write file to disk.\nThis is useful as a final flush of your results to disk if your application\nterminates as result of normal operation or an error. Manual flushing of\nyour results can be achieved by manually callingwrite_file().\nwrite_file()\nWrite results to a CSV file.\nIffilenameis not given,get_filename()is called.\nfilename\nget_filename()\nbool\nRead results from a TunableOp CSV file.\nIffilenameis not given,get_filename()is called.\nfilename\nget_filename()\nbool\ntune GEMM in file.\nProcess one or more files and distribute work over one or more GPUs.\nSet rotating buffer size to this value in MB, if the buffer size is greater than zero.\nIf less than zero, query L2 cache size. If equal to zero, means deactivate rotating buffer.\nGet the rotating buffer size in kilobytes.\nint",
  "url": "https://pytorch.org/docs/stable/cuda.tunable.html",
  "metadata": {
    "section": null,
    "issue_number": null,
    "labels": null,
    "answer_author": null
  }
}