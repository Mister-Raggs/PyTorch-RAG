{
  "doc_id": "d4fe7d0f4359a76814b73cb4146c01b8",
  "source": "pytorch_docs",
  "title": "Remote Reference Protocol \u2014 PyTorch 2.9 documentation",
  "text": "\n## Remote Reference Protocol#\n\nCreated On: Nov 20, 2019 | Last Updated On: Apr 27, 2025\nThis note describes the design details of Remote Reference protocol and walks\nthrough message flows in different scenarios. Make sure you\u2019re familiar with theDistributed RPC Frameworkbefore proceeding.\n\n## Background#\n\nRRef stands for Remote REFerence. It is a reference of an object which is\nlocated on the local or remote worker, and transparently handles reference\ncounting under the hood. Conceptually, it can be considered as a distributed\nshared pointer. Applications can create an RRef by callingremote(). Each RRef is owned by the callee worker\nof theremote()call (i.e., owner) and can be used\nby multiple users. The owner stores the real data and keeps track of the global\nreference count. Every RRef can be uniquely identified by a globalRRefId,\nwhich is assigned at the time of creation on the caller of theremote()call.\nremote()\nremote()\nRRefId\nremote()\nOn the owner worker, there is only oneOwnerRRefinstance, which contains\nthe real data, while on user workers, there can be as manyUserRRefsas\nnecessary, andUserRRefdoes not hold the data. All usage on the owner will\nretrieve the uniqueOwnerRRefinstance using the globally uniqueRRefId.\nAUserRRefwill be created when it is used as an argument or return value inrpc_sync(),rpc_async()orremote()invocation, and the owner will be notified\naccording to update the reference count. AnOwnerRRefand its data will be\ndeleted when there is noUserRRefinstances globally and there are no\nreference to theOwnerRRefon the owner as well.\nOwnerRRef\nUserRRefs\nUserRRef\nOwnerRRef\nRRefId\nUserRRef\nrpc_sync()\nrpc_async()\nremote()\nOwnerRRef\nUserRRef\nOwnerRRef\n\n## Assumptions#\n\nRRef protocol is designed with the following assumptions.\nTransient Network Failures: The RRef design handles transient\nnetwork failures by retrying messages. It cannot handle node crashes or\npermanent network partitions. When those incidents occur, the application\nshould take down all workers, revert to the previous checkpoint, and resume\ntraining.\nNon-idempotent UDFs: We assume the user functions (UDF) provided torpc_sync(),rpc_async()orremote()are not idempotent and therefore\ncannot be retried. However, internal RRef control messages are idempotent and\nretried upon message failure.\nrpc_sync()\nrpc_async()\nremote()\nOut of Order Message Delivery: We do not assume message delivery order\nbetween any pair of nodes, because both sender and receiver are using multiple\nthreads. There is no guarantee on which message will be processed first.\n\n## RRef Lifetime#\n\nThe goal of the protocol is to delete anOwnerRRefat an appropriate time.\nThe right time to delete anOwnerRRefis when there are no livingUserRRefinstances and user code is not holding references to theOwnerRRefeither. The tricky part is to determine if there are any livingUserRRefinstances.\nOwnerRRef\nOwnerRRef\nUserRRef\nOwnerRRef\nUserRRef\n\n## Design Reasoning#\n\nA user can get aUserRRefin three situations:\nUserRRef\nReceiving aUserRReffrom the owner.\nUserRRef\nReceiving aUserRReffrom another user.\nUserRRef\nCreating a newUserRRefowned by another worker.\nUserRRef\nCase 1 is the simplest where the owner passes its RRef to a user, where the\nowner callsrpc_sync(),rpc_async(), orremote()and uses its RRef as an argument. In this\ncase a newUserRRefwill be created on the user. As the owner is the caller,\nit can easily update its local reference count on theOwnerRRef.\nrpc_sync()\nrpc_async()\nremote()\nUserRRef\nOwnerRRef\nThe only requirement is that anyUserRRefmust notify the owner upon destruction. Hence, we need the first\nguarantee:\nUserRRef\nG1. The owner will be notified when any UserRRef is deleted.\nAs messages might come delayed or out-of-order, we need one more guarantee to\nmake sure the delete message is not processed too soon. If A sends a message to\nB that involves an RRef, we call the RRef on A (the parent RRef) and the RRef on B\n(the child RRef).\nG2. Parent RRef will NOT be deleted until the child RRef is confirmed by the\nowner.\nIn cases 2 and 3, it is possible that the owner has only partial or no knowledge\nat all about the RRef fork graph. For example, an RRef could be\nconstructed on a user, and before the owner receives any RPC call, the\ncreator user might have already shared the RRef with other users, and those\nusers could further share the RRef. One invariant is that the fork graph of\nany RRef is always a tree, because forking an RRef always\ncreates a newUserRRefinstance on the callee (except if the callee is the\nowner), and hence every RRef has a single parent.\nUserRRef\nThe owner\u2019s view on anyUserRRefin the tree has three stages:\nUserRRef\n\n```python\n1) unknown -> 2) known -> 3) deleted.\n\n```\n\nThe owner\u2019s view of the entire tree keeps changing. The owner deletes itsOwnerRRefinstance when it thinks there are no livingUserRRefinstances, i.e.,\nwhenOwnerRRefis deleted, allUserRRefinstances could be either indeed\ndeleted or unknown. The dangerous case is when some forks are unknown and others\nare deleted.\nOwnerRRef\nUserRRef\nOwnerRRef\nUserRRef\nG2trivially guarantees that no parentUserRRefcan be deleted before\nthe owner knows all of its childrenUserRRefinstances. However, it is\npossible that the childUserRRefmay be deleted before the owner knows its\nparentUserRRef.\nUserRRef\nUserRRef\nUserRRef\nUserRRef\nConsider the following example, where theOwnerRRefforks to A, then A forks\nto Y, and Y forks to Z:\nOwnerRRef\n\n```python\nOwnerRRef -> A -> Y -> Z\n\n```\n\nIf all of Z\u2019s messages, including the delete message, are processed by the\nowner before Y\u2019s messages. the owner will learn of Z\u2019s deletion before\nknowing Y exists. Nevertheless, this does not cause any problem. Because, at least\none of Y\u2019s ancestors will be alive (A) and it will\nprevent the owner from deleting theOwnerRRef. More specifically, if the\nowner does not know Y, A cannot be deleted due toG2, and the owner knows A\nsince it is A\u2019s parent.\nOwnerRRef\nThings get a little trickier if the RRef is created on a user:\n\n```python\nOwnerRRef\n    ^\n    |\n    A -> Y -> Z\n\n```\n\nIf Z callsto_here()on theUserRRef, the\nowner at least knows A when Z is deleted, because otherwise,to_here()wouldn\u2019t finish. If Z does not callto_here(), it is possible that the owner\nreceives all messages from Z before any message from A and Y. In this case, as\nthe real data of theOwnerRRefhas not been created yet, there is nothing to\nbe deleted either. It is the same as Z does not exist at all. Hence, it\u2019s still\nOK.\nto_here()\nUserRRef\nto_here()\nto_here()\nOwnerRRef\n\n## Implementation#\n\nG1is implemented by sending out a delete message inUserRRefdestructor. To provideG2, the parentUserRRefis put into a context\nwhenever it is forked, indexed by the newForkId. The parentUserRRefis\nonly removed from the context when it receives an acknowledgement message (ACK)\nfrom the child, and the child will only send out the ACK when it is confirmed by\nthe owner.\nUserRRef\nUserRRef\nForkId\nUserRRef\n\n## Protocol Scenarios#\n\nLet\u2019s now discuss how the above designs translate to the protocol in four\nscenarios.\n\n## User Share RRef with Owner as Return Value#\n\n\n```python\nimport torch\nimport torch.distributed.rpc as rpc\n\n# on worker A\nrref = rpc.remote('B', torch.add, args=(torch.ones(2), 1))\n# say the rref has RRefId 100 and ForkId 1\nrref.to_here()\n\n```\n\nIn this case, theUserRRefis created on the user worker A, then it is\npassed to the owner worker B together with the remote message, and then B\ncreates theOwnerRRef. The methodremote()returns immediately, meaning that theUserRRefcan be forked/used before\nthe owner knows about it.\nUserRRef\nOwnerRRef\nremote()\nUserRRef\nOn the owner, when receiving theremote()call, it\nwill create theOwnerRRef, and returns an ACK to acknowledge{100,1}(RRefId,ForkId). Only after receiving this ACK, can A delete itsUserRRef. This involves bothG1andG2.G1is obvious. ForG2, theOwnerRRefis a child of theUserRRef, and theUserRRefis not deleted until it receives the ACK from the owner.\nremote()\nOwnerRRef\n{100,1}\nRRefId\nForkId\nUserRRef\nOwnerRRef\nUserRRef\nUserRRef\nThe diagram above shows the message flow, where solid arrow contains user\nfunction and dashed arrow are builtin messages. Note that the first two messages\nfrom A to B (remote()andto_here()) may\narrive at B in any order, but the final delete message will only be sent out\nwhen:\nremote()\nto_here()\nB acknowledgesUserRRef{100,1}(G2), and\nUserRRef{100,1}\nPython GC agrees to delete the localUserRRefinstance. This occurs when\nthe RRef is no longer in scope and is eligible for garbage collection.\nUserRRef\n\n## User Share RRef with Owner as Argument#\n\n\n```python\nimport torch\nimport torch.distributed.rpc as rpc\n\n# on worker A and worker B\ndef func(rref):\n  pass\n\n# on worker A\nrref = rpc.remote('B', torch.add, args=(torch.ones(2), 1))\n# say the rref has RRefId 100 and ForkId 1\nrpc.rpc_async('B', func, args=(rref, ))\n\n```\n\nIn this case, after creating theUserRRefon A, A uses it as an argument in\na followup RPC call to B. A will keepUserRRef{100,1}alive until it\nreceives the acknowledge from B (G2, not the return value of the RPC call).\nThis is necessary because A should not send out the delete message until all\nprevious messages are received, otherwise, theOwnerRRefcould be\ndeleted before usage as we do not guarantee message delivery order. This is done\nby creating a childForkIdof RRef, holding them in a map until receives the\nowner confirms the childForkId. The figure below shows the message flow.\nUserRRef\nUserRRef{100,1}\nOwnerRRef\nForkId\nForkId\nNote that theUserRRefcould be deleted on B before func finishes or even\nstarts. However this is OK, as at the time B sends out ACK for the childForkId, it already acquired theOwnerRRefinstance, which would prevent\nit been deleted too soon.\nUserRRef\nForkId\nOwnerRRef\n\n## Owner Share RRef with User#\n\nOwner to user is the simplest case, where the owner can update reference\ncounting locally, and does not need any additional control message to notify\nothers. RegardingG2, it is same as the parent receives the ACK from the\nowner immediately, as the parent is the owner.\n\n```python\nimport torch\nimport torch.distributed.rpc as RRef, rpc\n\n# on worker B and worker C\ndef func(rref):\n  pass\n\n# on worker B, creating a local RRef\nrref = RRef(\"data\")\n# say the rref has RRefId 100\ndist.rpc_async('C', func, args=(rref, ))\n\n```\n\nThe figure above shows the message flow. Note that when theOwnerRRefexits\nscope after the rpc_async call, it will not be deleted, because internally\nthere is a map to hold it alive if there is any known forks, in which case isUserRRef{100,1}. (G2)\nOwnerRRef\nUserRRef{100,1}\n\n## User Share RRef with User#\n\nThis is the most complicated case where caller user (parentUserRRef),\ncallee user (childUserRRef), and the owner all need to get involved.\nUserRRef\nUserRRef\n\n```python\nimport torch\nimport torch.distributed.rpc as rpc\n\n# on worker A and worker C\ndef func(rref):\n  pass\n\n# on worker A\nrref = rpc.remote('B', torch.add, args=(torch.ones(2), 1))\n# say the rref has RRefId 100 and ForkId 1\nrpc.rpc_async('C', func, args=(rref, ))\n\n```\n\nWhen C receives the childUserRReffrom A, it sends out a fork request to\nthe owner B. Later, when the B confirms theUserRRefon C, C will perform\ntwo actions in parallel: 1) send out the child ACK to A ,and 2) run the user\nprovided function. During this time, the parent (A) will hold itsUserRRef{100,1}alive to achieveG2.\nUserRRef\nUserRRef\nUserRRef{100,1}",
  "url": "https://pytorch.org/docs/stable/rpc/rref.html",
  "metadata": {
    "section": null,
    "issue_number": null,
    "labels": null,
    "answer_author": null
  }
}