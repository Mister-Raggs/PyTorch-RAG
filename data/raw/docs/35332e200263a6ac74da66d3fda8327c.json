{
  "doc_id": "35332e200263a6ac74da66d3fda8327c",
  "source": "pytorch_docs",
  "title": "PT2 Archive Spec \u2014 PyTorch 2.9 documentation",
  "text": "\n## PT2 Archive Spec#\n\nCreated On: Jul 16, 2025 | Last Updated On: Sep 09, 2025\nThe following specification defines the archive format which can be produced\nthrough the following methods:\ntorch.exportthrough callingtorch.export.save()\ntorch.export.save()\nAOTInductorthrough callingtorch._inductor.aoti_compile_and_package()\ntorch._inductor.aoti_compile_and_package()\nThe archive is a zipfile, and can be manipulated using standard zipfile APIs.\nThe following is a sample archive. We will walk through the archive folder by folder.\n\n```python\n.\n\u251c\u2500\u2500 archive_format\n\u251c\u2500\u2500 byteorder\n\u251c\u2500\u2500 .data\n\u2502   \u251c\u2500\u2500 serialization_id\n\u2502   \u2514\u2500\u2500 version\n\u251c\u2500\u2500 data\n\u2502   \u251c\u2500\u2500 aotinductor\n\u2502   \u2502   \u2514\u2500\u2500 model1\n\u2502   \u2502       \u251c\u2500\u2500 cf5ez6ifexr7i2hezzz4s7xfusj4wtisvu2gddeamh37bw6bghjw.kernel_metadata.json\n\u2502   \u2502       \u251c\u2500\u2500 cf5ez6ifexr7i2hezzz4s7xfusj4wtisvu2gddeamh37bw6bghjw.kernel.cpp\n\u2502   \u2502       \u251c\u2500\u2500 cf5ez6ifexr7i2hezzz4s7xfusj4wtisvu2gddeamh37bw6bghjw.wrapper_metadata.json\n\u2502   \u2502       \u251c\u2500\u2500 cf5ez6ifexr7i2hezzz4s7xfusj4wtisvu2gddeamh37bw6bghjw.wrapper.cpp\n\u2502   \u2502       \u251c\u2500\u2500 cf5ez6ifexr7i2hezzz4s7xfusj4wtisvu2gddeamh37bw6bghjw.wrapper.so\n\u2502   \u2502       \u251c\u2500\u2500 cg7domx3woam3nnliwud7yvtcencqctxkvvcafuriladwxw4nfiv.cubin\n\u2502   \u2502       \u2514\u2500\u2500 cubaaxppb6xmuqdm4bej55h2pftbce3bjyyvljxbtdfuolmv45ex.cubin\n\u2502   \u251c\u2500\u2500 weights\n\u2502   \u2502  \u251c\u2500\u2500 model1_weights_config.json\n\u2502   \u2502  \u251c\u2500\u2500 model2_weights_config.json\n\u2502   \u2502  \u251c\u2500\u2500 weight_0\n\u2502   \u2502  \u251c\u2500\u2500 weight_1\n\u2502   \u2502  \u251c\u2500\u2500 weight_2\n\u2502   \u2514\u2500\u2500 constants\n\u2502   \u2502  \u251c\u2500\u2500 model1_constants_config.json\n\u2502   \u2502  \u251c\u2500\u2500 model2_constants_config.json\n\u2502   \u2502  \u251c\u2500\u2500 tensor_0\n\u2502   \u2502  \u251c\u2500\u2500 tensor_1\n\u2502   \u2502  \u251c\u2500\u2500 custom_obj_0\n\u2502   \u2502  \u251c\u2500\u2500 custom_obj_1\n\u2502   \u2514\u2500\u2500 sample_inputs\n\u2502       \u251c\u2500\u2500 model1.pt\n\u2502       \u2514\u2500\u2500 model2.pt\n\u251c\u2500\u2500 extra\n\u2502   \u2514\u2500\u2500 ....json\n\u2514\u2500\u2500 models\n    \u251c\u2500\u2500 model1.json\n    \u2514\u2500\u2500 model2.json\n\n```\n\n\n## Contents#\n\n\n## Archive Headers#\n\narchive_formatdeclares the format used by this archive. Currently, it can only be \u201cpt2\u201d.\narchive_format\nbyteorder. One of \u201clittle\u201d or \u201cbig\u201d, used by zip file reader\nbyteorder\n/.data/versioncontains the archive version. (Notice that this is neither export serialization\u2019s schema version, nor Aten Opset Version).\n/.data/version\n/.data/serialization_idis a hash generated for the current archive, used for verification.\n/.data/serialization_id\n\n## AOTInductor Compiled Artifact#\n\nPath:/data/aotinductor/<model_name>-<backend>/\n/data/aotinductor/<model_name>-<backend>/\nAOTInductor compilation artifacts are saved for each model-backend pair. For\nexample, compilation artifacts for themodel1model on A100 and H100 will be\nsaved inmodel1-a100andmodel1-h100folders separately.\nmodel1\nmodel1-a100\nmodel1-h100\nThe folder typically contains\n<uuid>.wrapper.so: Dynamic library compiled from.cpp.\n<uuid>.wrapper.so\n<uuid>.wrapper.cpp: AOTInductor generated cpp wrapper file.\n<uuid>.wrapper.cpp\n<uuid>.kernel.cpp: AOTInductor generated cpp kernel file.\n<uuid>.kernel.cpp\n*.cubin: Triton kernels compiled from triton codegen kernels\n*.cubin\n<uuid>.wrapper_metadata.json: Metadata which was passed in from theaot_inductor.metadatainductor config\n<uuid>.wrapper_metadata.json\naot_inductor.metadata\n(optional)<uuid>.json: External fallback nodes for custom ops to be executed byProxyExecutor, serialized according toExternKernelNodestruct. If the model doesn\u2019t use custom ops/ProxyExecutor, this file would be omitted.\n<uuid>.json\nProxyExecutor\nExternKernelNode\n\n## Weights#\n\nPath:/data/weights/*\n/data/weights/*\nModel parameters and buffers are saved in the/data/weights/folder. Each\ntensor is saved as a separated file. The file only contains the raw data blob,\ntensor metadata and mapping from model weight FQN to saved raw data blob are saved separately in the<model_name>_weights_config.json.\n/data/weights/\n<model_name>_weights_config.json\n\n## Constants#\n\nPath:/data/constants/*\n/data/constants/*\nTensorConstants, non-persistent buffers and TorchBind objects are saved in the/data/constants/folder. Metadata and mapping from model constant FQN to saved raw data blob are saved separately in the<model_name>_constants_config.json\n/data/constants/\n<model_name>_constants_config.json\n\n## Sample Inputs#\n\nPath:/data/sample_inputs/<model_name>.pt\n/data/sample_inputs/<model_name>.pt\nThesample_inputused bytorch.exportcould be included in the archive for\ndownstream use. Typically, it\u2019s a flattened list of Tensors, combining both args\nand kwargs of the forward() function.\nsample_input\ntorch.export\nThe .pt file is produced bytorch.save(sample_input), and can be loaded bytorch.load()in python andtorch::pickle_load()in c++.\ntorch.save(sample_input)\ntorch.load()\ntorch::pickle_load()\nWhen the model has multiple copies of sample input, it would be packaged as<model_name>_<index>.pt.\n<model_name>_<index>.pt\n\n## Models Definitions#\n\nPath:/models/<model_name>.json\n/models/<model_name>.json\nModel definition is the serialized json of the ExportedProgram fromtorch.export.save, and other model-level metadata.\ntorch.export.save\n\n## Multiple Models#\n\nThis archive spec supports multiple model definitions coexisting in the same\nfile, with<model_name>serving as a unique identifier for the models, and\nwill be used as reference in other folders of the archive.\n<model_name>\nLower level APIs liketorch.export.pt2_archive._package.package_pt2()andtorch.export.pt2_archive._package.load_pt2()allow you to have\nfiner-grained control over the packaging and loading process.\ntorch.export.pt2_archive._package.package_pt2()\ntorch.export.pt2_archive._package.load_pt2()",
  "url": "https://pytorch.org/docs/stable/export/pt2_archive.html",
  "metadata": {
    "section": null,
    "issue_number": null,
    "labels": null,
    "answer_author": null
  }
}