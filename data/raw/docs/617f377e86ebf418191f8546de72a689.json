{
  "doc_id": "617f377e86ebf418191f8546de72a689",
  "source": "pytorch_docs",
  "title": "Expiration Timers \u2014 PyTorch 2.9 documentation",
  "text": "\n## Expiration Timers#\n\nCreated On: May 04, 2021 | Last Updated On: Apr 25, 2024\nExpiration timers are set up on the same process as the agent and\nused from your script to deal with stuck workers. When you go into\na code-block that has the potential to get stuck you can acquire\nan expiration timer, which instructs the timer server to kill the\nprocess if it does not release the timer by the self-imposed expiration\ndeadline.\nUsage:\n\n```python\nimport torchelastic.timer as timer\nimport torchelastic.agent.server as agent\n\ndef main():\n    start_method = \"spawn\"\n    message_queue = mp.get_context(start_method).Queue()\n    server = timer.LocalTimerServer(message, max_interval=0.01)\n    server.start() # non-blocking\n\n    spec = WorkerSpec(\n                fn=trainer_func,\n                args=(message_queue,),\n                ...<OTHER_PARAMS...>)\n    agent = agent.LocalElasticAgent(spec, start_method)\n    agent.run()\n\ndef trainer_func(message_queue):\n    timer.configure(timer.LocalTimerClient(message_queue))\n    with timer.expires(after=60): # 60 second expiry\n        # do some work\n\n```\n\nIn the example above iftrainer_functakes more than 60 seconds to\ncomplete, then the worker process is killed and the agent retries the worker group.\ntrainer_func\n\n## Client Methods#\n\nConfigures a timer client. Must be called before usingexpires.\nexpires\nAcquires a countdown timer that expires inafterseconds from now,\nunless the code-block that it wraps is finished within the timeframe.\nWhen the timer expires, this worker is eligible to be reaped. The\nexact meaning of \u201creaped\u201d depends on the client implementation. In\nmost cases, reaping means to terminate the worker process.\nNote that the worker is NOT guaranteed to be reaped at exactlytime.now()+after, but rather the worker is \u201celigible\u201d for being\nreaped and theTimerServerthat the client talks to will ultimately\nmake the decision when and how to reap the workers with expired timers.\nafter\ntime.now()+after\nTimerServer\nUsage:\n\n```python\ntorch.distributed.elastic.timer.configure(LocalTimerClient())\nwith expires(after=10):\n    torch.distributed.all_reduce(...)\n\n```\n\n\n## Server/Client Implementations#\n\nBelow are the timer server and client pairs that are provided by torchelastic.\nNote\nTimer server and clients always have to be implemented and used\nin pairs since there is a messaging protocol between the server\nand client.\nBelow is a pair of timer server and client that is implemented based on\namultiprocess.Queue.\nmultiprocess.Queue\nServer that works withLocalTimerClient. Clients are expected to be\nsubprocesses to the parent process that is running this server. Each host\nin the job is expected to start its own timer server locally and each\nserver instance manages timers for local workers (running on processes\non the same host).\nLocalTimerClient\nClient side ofLocalTimerServer. This client is meant to be used\non the same host that theLocalTimerServeris running on and uses\npid to uniquely identify a worker. This is particularly useful in situations\nwhere one spawns a subprocess (trainer) per GPU on a host with multiple\nGPU devices.\nLocalTimerServer\nLocalTimerServer\nBelow is another pair of timer server and client that is implemented\nbased on a named pipe.\nServer that works withFileTimerClient. Clients are expected to be\nrunning on the same host as the process that is running this server.\nEach host in the job is expected to start its own timer server locally\nand each server instance manages timers for local workers (running on\nprocesses on the same host).\nFileTimerClient\nfile_path(str) \u2013 str, the path of a FIFO special file to be created.\nmax_interval(float) \u2013 float, max interval in seconds for each watchdog loop.\ndaemon(bool) \u2013 bool, running the watchdog thread in daemon mode or not.\nA daemon thread will not block a process to stop.\nlog_event(Optional[Callable[[str,Optional[FileTimerRequest]],None]]) \u2013 Callable[[Dict[str, str]], None], an optional callback for\nlogging the events in JSON format.\nClient side ofFileTimerServer. This client is meant to be used\non the same host that theFileTimerServeris running on and uses\npid to uniquely identify a worker.\nThis client uses a named_pipe to send timer requests to theFileTimerServer. This client is a producer while theFileTimerServeris a consumer. Multiple clients can work with\nthe sameFileTimerServer.\nFileTimerServer\nFileTimerServer\nFileTimerServer\nFileTimerServer\nFileTimerServer\nfile_path(str) \u2013 str, the path of a FIFO special file.FileTimerServermust have created it by calling os.mkfifo().\nFileTimerServer\nsignal\u2013 signal, the signal to use to kill the process. Using a\nnegative or zero signal will not kill the process.\n\n## Writing a custom timer server/client#\n\nTo write your own timer server and client extend thetorch.distributed.elastic.timer.TimerServerfor the server andtorch.distributed.elastic.timer.TimerClientfor the client. TheTimerRequestobject is used to pass messages between\nthe server and client.\ntorch.distributed.elastic.timer.TimerServer\ntorch.distributed.elastic.timer.TimerClient\nTimerRequest\nData object representing a countdown timer acquisition and release\nthat is used between theTimerClientandTimerServer.\nA negativeexpiration_timeshould be interpreted as a \u201crelease\u201d\nrequest.\nTimerClient\nTimerServer\nexpiration_time\nNote\nthe type ofworker_idis implementation specific.\nIt is whatever the TimerServer and TimerClient implementations\nhave on to uniquely identify a worker.\nworker_id\nEntity that monitors active timers and expires them\nin a timely fashion. This server is responsible for\nreaping workers that have expired timers.\nClears all timers for the givenworker_ids.\nworker_ids\nReturns all expired timers for each worker_id. An expired timer\nis a timer for which the expiration_time is less than or equal to\nthe provided deadline.\ndict[str,list[torch.distributed.elastic.timer.api.TimerRequest]]\nProcesses the incoming timer requests and registers them with the server.\nThe timer request can either be a acquire-timer or release-timer request.\nTimer requests with a negative expiration_time should be interpreted\nas a release-timer request.\nClient library to acquire and release countdown timers by communicating\nwith the TimerServer.\nAcquires a timer for the worker that holds this client object\ngiven the scope_id and expiration_time. Typically registers\nthe timer with the TimerServer.\nReleases the timer for thescope_idon the worker this\nclient represents. After this method is\ncalled, the countdown timer on the scope is no longer in effect.\nscope_id\n\n## Debug info logging#\n",
  "url": "https://pytorch.org/docs/stable/elastic/timer.html",
  "metadata": {
    "section": null,
    "issue_number": null,
    "labels": null,
    "answer_author": null
  }
}