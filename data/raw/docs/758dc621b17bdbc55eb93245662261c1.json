{
  "doc_id": "758dc621b17bdbc55eb93245662261c1",
  "source": "pytorch_docs",
  "title": "Tensor Attributes \u2014 PyTorch 2.9 documentation",
  "text": "\n## Tensor Attributes#\n\nCreated On: Apr 21, 2018 | Last Updated On: Jun 27, 2025\nEachtorch.Tensorhas atorch.dtype,torch.device, andtorch.layout.\ntorch.Tensor\ntorch.dtype\ntorch.device\ntorch.layout\n\n## torch.dtype#\n\nAtorch.dtypeis an object that represents the data type of atorch.Tensor. PyTorch has several different data types:\ntorch.dtype\ntorch.Tensor\nFloating point dtypes\ndtype\ndescription\ntorch.float32ortorch.float\ntorch.float32\ntorch.float\n32-bit floating point, as defined inhttps://en.wikipedia.org/wiki/IEEE_754\ntorch.float64ortorch.double\ntorch.float64\ntorch.double\n64-bit floating point, as defined inhttps://en.wikipedia.org/wiki/IEEE_754\ntorch.float16ortorch.half\ntorch.float16\ntorch.half\n16-bit floating point, as defined inhttps://en.wikipedia.org/wiki/IEEE_754, S-E-M 1-5-10\ntorch.bfloat16\ntorch.bfloat16\n16-bit floating point, sometimes referred to as Brain floating point, S-E-M 1-8-7\ntorch.complex32ortorch.chalf\ntorch.complex32\ntorch.chalf\n32-bit complex with twofloat16components\ntorch.complex64ortorch.cfloat\ntorch.complex64\ntorch.cfloat\n64-bit complex with twofloat32components\ntorch.complex128ortorch.cdouble\ntorch.complex128\ntorch.cdouble\n128-bit complex with twofloat64components\ntorch.float8_e4m3fn[shell],1\ntorch.float8_e4m3fn\n8-bit floating point, S-E-M 1-4-3, fromhttps://arxiv.org/abs/2209.05433\ntorch.float8_e5m2[shell]\ntorch.float8_e5m2\n8-bit floating point, S-E-M 1-5-2, fromhttps://arxiv.org/abs/2209.05433\ntorch.float8_e4m3fnuz[shell],1\ntorch.float8_e4m3fnuz\n8-bit floating point, S-E-M 1-4-3, fromhttps://arxiv.org/pdf/2206.02915\ntorch.float8_e5m2fnuz[shell],1\ntorch.float8_e5m2fnuz\n8-bit floating point, S-E-M 1-5-2, fromhttps://arxiv.org/pdf/2206.02915\ntorch.float8_e8m0fnu[shell],1\ntorch.float8_e8m0fnu\n8-bit floating point, S-E-M 0-8-0, fromhttps://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf\ntorch.float4_e2m1fn_x2[shell],1\ntorch.float4_e2m1fn_x2\npacked 4-bit floating point, S-E-M 1-2-1, fromhttps://www.opencompute.org/documents/ocp-microscaling-formats-mx-v1-0-spec-final-pdf\nInteger dtypes\ndtype\ndescription\ntorch.uint8\ntorch.uint8\n8-bit integer (unsigned)\ntorch.int8\ntorch.int8\n8-bit integer (signed)\ntorch.uint16[shell],2\ntorch.uint16\n16-bit integer (unsigned)\ntorch.int16ortorch.short\ntorch.int16\ntorch.short\n16-bit integer (signed)\ntorch.uint32[shell],2\ntorch.uint32\n32-bit integer (unsigned)\ntorch.int32ortorch.int\ntorch.int32\ntorch.int\n32-bit integer (signed)\ntorch.uint64[shell],2\ntorch.uint64\n64-bit integer (unsigned)\ntorch.int64ortorch.long\ntorch.int64\ntorch.long\n64-bit integer (signed)\ntorch.bool\ntorch.bool\nBoolean\na shell dtype a specialized dtype with limited op and backend support.\nSpecifically, ops that support tensor creation (torch.empty,torch.fill,torch.zeros)\nand operations which do not peek inside the data elements (torch.cat,torch.view,torch.reshape)\nare supported.  Ops that peek inside the data elements such as casting,\nmatrix multiplication, nan/inf checks are supported only on a case by\ncase basis, depending on maturity and presence of hardware accelerated kernels\nand established use cases.\ntorch.empty\ntorch.fill\ntorch.zeros\ntorch.cat\ntorch.view\ntorch.reshape\nThe \u201cfn\u201d, \u201cfnu\u201d and \u201cfnuz\u201d dtype suffixes mean:\n\u201cf\u201d - finite value encodings only, no infinity;\n\u201cn\u201d - nan value encodings differ from the IEEE spec;\n\u201cuz\u201d - \u201cunsigned zero\u201d only, i.e. no negative zero encoding\nUnsigned types asides fromuint8are currently planned to only have\nlimited support in eager mode (they primarily exist to assist usage with\ntorch.compile); if you need eager support and the extra range is not needed,\nwe recommend using their signed variants instead.  Seepytorch/pytorch#58734for more details.\nuint8\nNote: legacy constructors such astorch.*.FloatTensor,torch.*.DoubleTensor,torch.*.HalfTensor,torch.*.BFloat16Tensor,torch.*.ByteTensor,torch.*.CharTensor,torch.*.ShortTensor,torch.*.IntTensor,torch.*.LongTensor,torch.*.BoolTensoronly remain for backwards compatibility and should no longer be used.\ntorch.*.FloatTensor\ntorch.*.DoubleTensor\ntorch.*.HalfTensor\ntorch.*.BFloat16Tensor\ntorch.*.ByteTensor\ntorch.*.CharTensor\ntorch.*.ShortTensor\ntorch.*.IntTensor\ntorch.*.LongTensor\ntorch.*.BoolTensor\nTo find out if atorch.dtypeis a floating point data type, the propertyis_floating_pointcan be used, which returnsTrueif the data type is a floating point data type.\ntorch.dtype\nis_floating_point\nTrue\nTo find out if atorch.dtypeis a complex data type, the propertyis_complexcan be used, which returnsTrueif the data type is a complex data type.\ntorch.dtype\nis_complex\nTrue\nWhen the dtypes of inputs to an arithmetic operation (add,sub,div,mul) differ, we promote\nby finding the minimum dtype that satisfies the following rules:\nIf the type of a scalar operand is of a higher category than tensor operands\n(where complex > floating > integral > boolean), we promote to a type with sufficient size to hold\nall scalar operands of that category.\nIf a zero-dimension tensor operand has a higher category than dimensioned operands,\nwe promote to a type with sufficient size and category to hold all zero-dim tensor operands of\nthat category.\nIf there are no higher-category zero-dim operands, we promote to a type with sufficient size\nand category to hold all dimensioned operands.\nA floating point scalar operand has dtypetorch.get_default_dtype()and an integral\nnon-boolean scalar operand has dtypetorch.int64. Unlike numpy, we do not inspect\nvalues when determining the minimumdtypesof an operand.  Complex types\nare not yet supported. Promotion for shell dtypes is not defined.\nPromotion Examples:\n\n```python\n>>> float_tensor = torch.ones(1, dtype=torch.float)\n>>> double_tensor = torch.ones(1, dtype=torch.double)\n>>> complex_float_tensor = torch.ones(1, dtype=torch.complex64)\n>>> complex_double_tensor = torch.ones(1, dtype=torch.complex128)\n>>> int_tensor = torch.ones(1, dtype=torch.int)\n>>> long_tensor = torch.ones(1, dtype=torch.long)\n>>> uint_tensor = torch.ones(1, dtype=torch.uint8)\n>>> bool_tensor = torch.ones(1, dtype=torch.bool)\n# zero-dim tensors\n>>> long_zerodim = torch.tensor(1, dtype=torch.long)\n>>> int_zerodim = torch.tensor(1, dtype=torch.int)\n\n>>> torch.add(5, 5).dtype\ntorch.int64\n# 5 is an int64, but does not have higher category than int_tensor so is not considered.\n>>> (int_tensor + 5).dtype\ntorch.int32\n>>> (int_tensor + long_zerodim).dtype\ntorch.int32\n>>> (long_tensor + int_tensor).dtype\ntorch.int64\n>>> (bool_tensor + long_tensor).dtype\ntorch.int64\n>>> (bool_tensor + uint_tensor).dtype\ntorch.uint8\n>>> (float_tensor + double_tensor).dtype\ntorch.float64\n>>> (complex_float_tensor + complex_double_tensor).dtype\ntorch.complex128\n>>> (bool_tensor + int_tensor).dtype\ntorch.int32\n# Since long is a different kind than float, result dtype only needs to be large enough\n# to hold the float.\n>>> torch.add(long_tensor, float_tensor).dtype\ntorch.float32\n\n```\n\nAn integral output tensor cannot accept a floating point tensor.\nA boolean output tensor cannot accept a non-boolean tensor.\nA non-complex output tensor cannot accept a complex tensor\nCasting Examples:\n\n```python\n# allowed:\n>>> float_tensor *= float_tensor\n>>> float_tensor *= int_tensor\n>>> float_tensor *= uint_tensor\n>>> float_tensor *= bool_tensor\n>>> float_tensor *= double_tensor\n>>> int_tensor *= long_tensor\n>>> int_tensor *= uint_tensor\n>>> uint_tensor *= int_tensor\n\n# disallowed (RuntimeError: result type can't be cast to the desired output type):\n>>> int_tensor *= float_tensor\n>>> bool_tensor *= int_tensor\n>>> bool_tensor *= uint_tensor\n>>> float_tensor *= complex_float_tensor\n\n```\n\n\n## torch.device#\n\nAtorch.deviceis an object representing the device on which atorch.Tensoris\nor will be allocated.\ntorch.device\ntorch.Tensor\nThetorch.devicecontains a device type (most commonly \u201ccpu\u201d or\n\u201ccuda\u201d, but also potentially\u201cmps\u201d,\u201cxpu\u201d,\u201cxla\u201dor\u201cmeta\u201d) and optional\ndevice ordinal for the device type. If the device ordinal is not present, this object will always represent\nthe current device for the device type, even aftertorch.cuda.set_device()is called; e.g.,\natorch.Tensorconstructed with device'cuda'is equivalent to'cuda:X'where X is\nthe result oftorch.cuda.current_device().\ntorch.device\ntorch.cuda.set_device()\ntorch.Tensor\n'cuda'\n'cuda:X'\ntorch.cuda.current_device()\nAtorch.Tensor\u2019s device can be accessed via theTensor.deviceproperty.\ntorch.Tensor\nTensor.device\nAtorch.devicecan be constructed using:\ntorch.device\nA device string, which is a string representation of the device type and optionally the device ordinal.\nA device type and a device ordinal.\nA device ordinal, where the currentacceleratortype will be used.\nVia a device string:\n\n```python\n>>> torch.device('cuda:0')\ndevice(type='cuda', index=0)\n\n>>> torch.device('cpu')\ndevice(type='cpu')\n\n>>> torch.device('mps')\ndevice(type='mps')\n\n>>> torch.device('cuda')  # implicit index is the \"current device index\"\ndevice(type='cuda')\n\n```\n\nVia a device type and a device ordinal:\n\n```python\n>>> torch.device('cuda', 0)\ndevice(type='cuda', index=0)\n\n>>> torch.device('mps', 0)\ndevice(type='mps', index=0)\n\n>>> torch.device('cpu', 0)\ndevice(type='cpu', index=0)\n\n```\n\nVia a device ordinal:\nNote\nThis method will raise a RuntimeError if no accelerator is currently detected.\n\n```python\n>>> torch.device(0)  # the current accelerator is cuda\ndevice(type='cuda', index=0)\n\n>>> torch.device(1)  # the current accelerator is xpu\ndevice(type='xpu', index=1)\n\n>>> torch.device(0)  # no current accelerator detected\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nRuntimeError: Cannot access accelerator device when none is available.\n\n```\n\nThe device object can also be used as a context manager to change the default\ndevice tensors are allocated on:\n\n```python\n>>> with torch.device('cuda:1'):\n...     r = torch.randn(2, 3)\n>>> r.device\ndevice(type='cuda', index=1)\n\n```\n\nThis context manager has no effect if a factory function is passed an explicit,\nnon-None device argument.  To globally change the default device, see alsotorch.set_default_device().\ntorch.set_default_device()\nWarning\nThis function imposes a slight performance cost on every Python\ncall to the torch API (not just factory functions).  If this\nis causing problems for you, please comment onpytorch/pytorch#92701\nNote\nThetorch.deviceargument in functions can generally be substituted with a string.\nThis allows for fast prototyping of code.\ntorch.device\n\n```python\n>>> # Example of a function that takes in a torch.device\n>>> cuda1 = torch.device('cuda:1')\n>>> torch.randn((2,3), device=cuda1)\n\n```\n\n\n```python\n>>> # You can substitute the torch.device with a string\n>>> torch.randn((2,3), device='cuda:1')\n\n```\n\nNote\nMethods which take a device will generally accept a (properly formatted) string\nor an integer device ordinal, i.e. the following are all equivalent:\n\n```python\n>>> torch.randn((2,3), device=torch.device('cuda:1'))\n>>> torch.randn((2,3), device='cuda:1')\n>>> torch.randn((2,3), device=1)  # equivalent to 'cuda:1' if the current accelerator is cuda\n\n```\n\nNote\nTensors are never moved automatically between devices and require an explicit call from the user. Scalar Tensors (with tensor.dim()==0) are the only exception to this rule and they are automatically transferred from CPU to GPU when needed as this operation can be done \u201cfor free\u201d.\nExample:\n\n```python\n>>> # two scalars\n>>> torch.ones(()) + torch.ones(()).cuda()  # OK, scalar auto-transferred from CPU to GPU\n>>> torch.ones(()).cuda() + torch.ones(())  # OK, scalar auto-transferred from CPU to GPU\n\n```\n\n\n```python\n>>> # one scalar (CPU), one vector (GPU)\n>>> torch.ones(()) + torch.ones(1).cuda()  # OK, scalar auto-transferred from CPU to GPU\n>>> torch.ones(1).cuda() + torch.ones(())  # OK, scalar auto-transferred from CPU to GPU\n\n```\n\n\n```python\n>>> # one scalar (GPU), one vector (CPU)\n>>> torch.ones(()).cuda() + torch.ones(1)  # Fail, scalar not auto-transferred from GPU to CPU and non-scalar not auto-transferred from CPU to GPU\n>>> torch.ones(1) + torch.ones(()).cuda()  # Fail, scalar not auto-transferred from GPU to CPU and non-scalar not auto-transferred from CPU to GPU\n\n```\n\n\n## torch.layout#\n\nWarning\nThetorch.layoutclass is in beta and subject to change.\ntorch.layout\nAtorch.layoutis an object that represents the memory layout of atorch.Tensor. Currently, we supporttorch.strided(dense Tensors)\nand have beta support fortorch.sparse_coo(sparse COO Tensors).\ntorch.layout\ntorch.Tensor\ntorch.strided\ntorch.sparse_coo\ntorch.stridedrepresents dense Tensors and is the memory layout that\nis most commonly used. Each strided tensor has an associatedtorch.Storage, which holds its data. These tensors provide\nmulti-dimensional,stridedview of a storage. Strides are a list of integers: the k-th stride\nrepresents the jump in the memory necessary to go from one element to the\nnext one in the k-th dimension of the Tensor. This concept makes it possible\nto perform many tensor operations efficiently.\ntorch.strided\ntorch.Storage\nExample:\n\n```python\n>>> x = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])\n>>> x.stride()\n(5, 1)\n\n>>> x.t().stride()\n(1, 5)\n\n```\n\nFor more information ontorch.sparse_cootensors, seetorch.sparse.\ntorch.sparse_coo\n\n## torch.memory_format#\n\nAtorch.memory_formatis an object representing the memory format on which atorch.Tensoris\nor will be allocated.\ntorch.memory_format\ntorch.Tensor\nPossible values are:\ntorch.contiguous_format:\nTensor is or will be allocated in dense non-overlapping memory. Strides represented by values in decreasing order.\ntorch.contiguous_format\ntorch.channels_last:\nTensor is or will be allocated in dense non-overlapping memory. Strides represented by values instrides[0]>strides[2]>strides[3]>strides[1]==1aka NHWC order.\ntorch.channels_last\nstrides[0]>strides[2]>strides[3]>strides[1]==1\ntorch.channels_last_3d:\nTensor is or will be allocated in dense non-overlapping memory. Strides represented by values instrides[0]>strides[2]>strides[3]>strides[4]>strides[1]==1aka NDHWC order.\ntorch.channels_last_3d\nstrides[0]>strides[2]>strides[3]>strides[4]>strides[1]==1\ntorch.preserve_format:\nUsed in functions likecloneto preserve the memory format of the input tensor. If input tensor is\nallocated in dense non-overlapping memory, the output tensor strides will be copied from the input.\nOtherwise output strides will followtorch.contiguous_format\ntorch.preserve_format\ntorch.contiguous_format",
  "url": "https://pytorch.org/docs/stable/tensor_attributes.html",
  "metadata": {
    "section": null,
    "issue_number": null,
    "labels": null,
    "answer_author": null
  }
}