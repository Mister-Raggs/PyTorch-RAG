{
  "doc_id": "063fdd35e76abeae908df4944dc70f6f",
  "source": "pytorch_docs",
  "title": "torch.onnx \u2014 PyTorch 2.9 documentation",
  "text": "\n## torch.onnx#\n\nCreated On: Jun 10, 2025 | Last Updated On: Aug 29, 2025\n\n## Overview#\n\nOpen Neural Network eXchange (ONNX)is an open standard\nformat for representing machine learning models. Thetorch.onnxmodule captures the computation graph from a\nnative PyTorchtorch.nn.Modulemodel and converts it into anONNX graph.\ntorch.onnx\ntorch.nn.Module\nThe exported model can be consumed by any of the manyruntimes that support ONNX, including\nMicrosoft\u2019sONNX Runtime.\nNext example shows how to export a simple model.\n\n```python\nimport torch\n\nclass MyModel(torch.nn.Module):\n    def __init__(self):\n        super(MyModel, self).__init__()\n        self.conv1 = torch.nn.Conv2d(1, 128, 5)\n\n    def forward(self, x):\n        return torch.relu(self.conv1(x))\n\ninput_tensor = torch.rand((1, 1, 128, 128), dtype=torch.float32)\n\nmodel = MyModel()\n\ntorch.onnx.export(\n    model,                  # model to export\n    (input_tensor,),        # inputs of the model,\n    \"my_model.onnx\",        # filename of the ONNX model\n    input_names=[\"input\"],  # Rename inputs for the ONNX model\n    dynamo=True             # True or False to select the exporter to use\n)\n\n```\n\n\n## torch.export-based ONNX Exporter#\n\nThe torch.export-based ONNX exporter is the newest exporter for PyTorch 2.6 and newer\ntorch.exportengine is leveraged to produce a traced graph representing only the Tensor computation of the function in an\nAhead-of-Time (AOT) fashion. The resulting traced graph (1) produces normalized operators in the functional\nATen operator set (as well as any user-specified custom operators), (2) has eliminated all Python control\nflow and data structures (with certain exceptions), and (3) records the set of shape constraints needed to\nshow that this normalization and control-flow elimination is sound for future inputs, before it is finally\ntranslated into an ONNX graph.\nLearn more about the torch.export-based ONNX Exporter\n\n## Frequently Asked Questions#\n\nQ: I have exported my LLM model, but its input size seems to be fixed?\nThe tracer records the shapes of the example inputs. If the model should accept\ninputs of dynamic shapes, setdynamic_shapeswhen callingtorch.onnx.export().\ndynamic_shapes\ntorch.onnx.export()\nQ: How to export models containing loops?\nSeetorch.cond.\n\n## Contributing / Developing#\n\nThe ONNX exporter is a community project and we welcome contributions. We follow thePyTorch guidelines for contributions, but you might\nalso be interested in reading ourdevelopment wiki.\n\n## torch.onnx APIs#\n\n\n## Functions#\n\nExports a model into ONNX format.\nSettingdynamo=Trueenables the new ONNX export logic\nwhich is based ontorch.export.ExportedProgramand a more modern\nset of translation logic. This is the recommended and default way to export models\nto ONNX.\ndynamo=True\ntorch.export.ExportedProgram\nWhendynamo=True:\ndynamo=True\nThe exporter tries the following strategies to get an ExportedProgram for conversion to ONNX.\nIf the model is already an ExportedProgram, it will be used as-is.\nUsetorch.export.export()and setstrict=False.\ntorch.export.export()\nstrict=False\nUsetorch.export.export()and setstrict=True.\ntorch.export.export()\nstrict=True\nmodel(torch.nn.Module|torch.export.ExportedProgram|torch.jit.ScriptModule|torch.jit.ScriptFunction) \u2013 The model to be exported.\nargs(tuple[Any,...]) \u2013 Example positional inputs. Any non-Tensor arguments will be hard-coded into the\nexported model; any Tensor arguments will become inputs of the exported model,\nin the order they occur in the tuple.\nf(str|os.PathLike|None) \u2013 Path to the output ONNX model file. E.g. \u201cmodel.onnx\u201d. This argument is kept for\nbackward compatibility. It is recommended to leave unspecified (None)\nand use the returnedtorch.onnx.ONNXProgramto serialize the model\nto a file instead.\ntorch.onnx.ONNXProgram\nkwargs(dict[str,Any]|None) \u2013 Optional example keyword inputs.\nverbose(bool|None) \u2013 Whether to enable verbose logging.\ninput_names(Sequence[str]|None) \u2013 names to assign to the input nodes of the graph, in order.\noutput_names(Sequence[str]|None) \u2013 names to assign to the output nodes of the graph, in order.\nopset_version(int|None) \u2013 The version of thedefault (ai.onnx) opsetto target. You should setopset_versionaccording to the supported opset versions\nof the runtime backend or compiler you want to run the exported model with.\nLeave as default (None) to use the recommended version, or refer to\nthe ONNX operators documentation for more information.\nopset_version\nNone\ndynamo(bool) \u2013 Whether to export the model withtorch.exportExportedProgram instead of TorchScript.\ntorch.export\nexternal_data(bool) \u2013 Whether to save the model weights as an external data file.\nThis is required for models with large weights that exceed the ONNX file size limit (2GB).\nWhen False, the weights are saved in the ONNX file with the model architecture.\ndynamic_shapes(dict[str,Any]|tuple[Any,...]|list[Any]|None) \u2013 A dictionary or a tuple of dynamic shapes for the model inputs. Refer totorch.export.export()for more details. This is only used (and preferred) when dynamo is True.\nNote that dynamic_shapes is designed to be used when the model is exported with dynamo=True, while\ndynamic_axes is used when dynamo=False.\ntorch.export.export()\ncustom_translation_table(dict[Callable,Callable|Sequence[Callable]]|None) \u2013 A dictionary of custom decompositions for operators in the model.\nThe dictionary should have the callable target in the fx Node as the key (e.g.torch.ops.aten.stft.default),\nand the value should be a function that builds that graph using ONNX Script. This option\nis only valid when dynamo is True.\ntorch.ops.aten.stft.default\nreport(bool) \u2013 Whether to generate a markdown report for the export process. This option\nis only valid when dynamo is True.\noptimize(bool) \u2013 Whether to optimize the exported model. This option\nis only valid when dynamo is True. Default is True.\nverify(bool) \u2013 Whether to verify the exported model using ONNX Runtime. This option\nis only valid when dynamo is True.\nprofile(bool) \u2013 Whether to profile the export process. This option\nis only valid when dynamo is True.\ndump_exported_program(bool) \u2013 Whether to dump thetorch.export.ExportedProgramto a file.\nThis is useful for debugging the exporter. This option is only valid when dynamo is True.\ntorch.export.ExportedProgram\nartifacts_dir(str|os.PathLike) \u2013 The directory to save the debugging artifacts like the report and the serialized\nexported program. This option is only valid when dynamo is True.\nfallback(bool) \u2013 Whether to fallback to the TorchScript exporter if the dynamo exporter fails.\nThis option is only valid when dynamo is True. When fallback is enabled, It is\nrecommended to set dynamic_axes even when dynamic_shapes is provided.\nexport_params(bool) \u2013When ``f`` is specified: If false, parameters (weights) will not be exported.You can also leave it unspecified and use the returnedtorch.onnx.ONNXProgramto control how initializers are treated when serializing the model.\nWhen ``f`` is specified: If false, parameters (weights) will not be exported.\nYou can also leave it unspecified and use the returnedtorch.onnx.ONNXProgramto control how initializers are treated when serializing the model.\ntorch.onnx.ONNXProgram\nkeep_initializers_as_inputs(bool) \u2013When ``f`` is specified: If True, all the\ninitializers (typically corresponding to model weights) in the\nexported graph will also be added as inputs to the graph. If False,\nthen initializers are not added as inputs to the graph, and only\nthe user inputs are added as inputs.Set this to True if you intend to supply model weights at runtime.\nSet it to False if the weights are static to allow for better optimizations\n(e.g. constant folding) by backends/runtimes.You can also leave it unspecified and use the returnedtorch.onnx.ONNXProgramto control how initializers are treated when serializing the model.\nWhen ``f`` is specified: If True, all the\ninitializers (typically corresponding to model weights) in the\nexported graph will also be added as inputs to the graph. If False,\nthen initializers are not added as inputs to the graph, and only\nthe user inputs are added as inputs.\nSet this to True if you intend to supply model weights at runtime.\nSet it to False if the weights are static to allow for better optimizations\n(e.g. constant folding) by backends/runtimes.\nYou can also leave it unspecified and use the returnedtorch.onnx.ONNXProgramto control how initializers are treated when serializing the model.\ntorch.onnx.ONNXProgram\ndynamic_axes(Mapping[str,Mapping[int,str]]|Mapping[str,Sequence[int]]|None) \u2013Prefer specifyingdynamic_shapeswhendynamo=Trueand whenfallbackis not enabled.By default the exported model will have the shapes of all input and output tensors\nset to exactly match those given inargs. To specify axes of tensors as\ndynamic (i.e. known only at run-time), setdynamic_axesto a dict with schema:KEY (str): an input or output name. Each name must also be provided ininput_namesoroutput_names.VALUE (dict or list): If a dict, keys are axis indices and values are axis names. If alist, each element is an axis index.For example:classSumModule(torch.nn.Module):defforward(self,x):returntorch.sum(x,dim=1)torch.onnx.export(SumModule(),(torch.ones(2,2),),\"onnx.pb\",input_names=[\"x\"],output_names=[\"sum\"],)Produces:input{name:\"x\"...shape{dim{dim_value:2# axis 0}dim{dim_value:2# axis 1...output{name:\"sum\"...shape{dim{dim_value:2# axis 0...While:torch.onnx.export(SumModule(),(torch.ones(2,2),),\"onnx.pb\",input_names=[\"x\"],output_names=[\"sum\"],dynamic_axes={# dict value: manually named axes\"x\":{0:\"my_custom_axis_name\"},# list value: automatic names\"sum\":[0],},)Produces:input{name:\"x\"...shape{dim{dim_param:\"my_custom_axis_name\"# axis 0}dim{dim_value:2# axis 1...output{name:\"sum\"...shape{dim{dim_param:\"sum_dynamic_axes_1\"# axis 0...\nPrefer specifyingdynamic_shapeswhendynamo=Trueand whenfallbackis not enabled.\ndynamic_shapes\ndynamo=True\nfallback\nBy default the exported model will have the shapes of all input and output tensors\nset to exactly match those given inargs. To specify axes of tensors as\ndynamic (i.e. known only at run-time), setdynamic_axesto a dict with schema:\nargs\ndynamic_axes\ninput_names\noutput_names.\noutput_names\nlist, each element is an axis index.\nFor example:\n\n```python\nclass SumModule(torch.nn.Module):\n    def forward(self, x):\n        return torch.sum(x, dim=1)\n\n\ntorch.onnx.export(\n    SumModule(),\n    (torch.ones(2, 2),),\n    \"onnx.pb\",\n    input_names=[\"x\"],\n    output_names=[\"sum\"],\n)\n\n```\n\nProduces:\n\n```python\ninput {\n  name: \"x\"\n  ...\n      shape {\n        dim {\n          dim_value: 2  # axis 0\n        }\n        dim {\n          dim_value: 2  # axis 1\n...\noutput {\n  name: \"sum\"\n  ...\n      shape {\n        dim {\n          dim_value: 2  # axis 0\n...\n\n```\n\nWhile:\n\n```python\ntorch.onnx.export(\n    SumModule(),\n    (torch.ones(2, 2),),\n    \"onnx.pb\",\n    input_names=[\"x\"],\n    output_names=[\"sum\"],\n    dynamic_axes={\n        # dict value: manually named axes\n        \"x\": {0: \"my_custom_axis_name\"},\n        # list value: automatic names\n        \"sum\": [0],\n    },\n)\n\n```\n\nProduces:\n\n```python\ninput {\n  name: \"x\"\n  ...\n      shape {\n        dim {\n          dim_param: \"my_custom_axis_name\"  # axis 0\n        }\n        dim {\n          dim_value: 2  # axis 1\n...\noutput {\n  name: \"sum\"\n  ...\n      shape {\n        dim {\n          dim_param: \"sum_dynamic_axes_1\"  # axis 0\n...\n\n```\n\ntraining(_C_onnx.TrainingMode) \u2013 Deprecated option. Instead, set the training mode of the model before exporting.\noperator_export_type(_C_onnx.OperatorExportTypes) \u2013 Deprecated option. Only ONNX is supported.\ndo_constant_folding(bool) \u2013 Deprecated option.\ncustom_opsets(Mapping[str,int]|None) \u2013 Deprecated option.\nexport_modules_as_functions(bool|Collection[type[torch.nn.Module]]) \u2013 Deprecated option.\nautograd_inlining(bool) \u2013 Deprecated option.\ntorch.onnx.ONNXProgramif dynamo is True, otherwise None.\ntorch.onnx.ONNXProgram\nONNXProgram| None\nChanged in version 2.6:trainingis now deprecated. Instead, set the training mode of the model before exporting.operator_export_typeis now deprecated. Only ONNX is supported.do_constant_foldingis now deprecated. It is always enabled.export_modules_as_functionsis now deprecated.autograd_inliningis now deprecated.\nChanged in version 2.7:optimizeis now True by default.\nChanged in version 2.9:dynamois now True by default.\nReturns whether it is in the middle of ONNX export.\nbool\n\n## Classes#\n\nA class to represent an ONNX program that is callable with torch tensors.\nmodel\u2013 The ONNX model as an ONNX IR model object.\nexported_program\u2013 The exported program that produced the ONNX model.\nErrors raised by the ONNX exporter. This is the base class for all exporter errors.\n\n## Deprecated APIs#\n\nDeprecated since version 2.6:These functions are deprecated and will be removed in a future version.\nRegisters a symbolic function for a custom operator.\nWhen the user registers symbolic for custom/contrib ops,\nit is highly recommended to add shape inference for that operator via setType API,\notherwise the exported graph may have incorrect shape inference in some extreme cases.\nAn example of setType istest_aten_embedding_2intest_operators.py.\nSee \u201cCustom Operators\u201d in the module documentation for an example usage.\nsymbolic_name(str) \u2013 The name of the custom operator in \u201c<domain>::<op>\u201d\nformat.\nsymbolic_fn(Callable) \u2013 A function that takes in the ONNX graph and\nthe input arguments to the current operator, and returns new\noperator nodes to add to the graph.\nopset_version(int) \u2013 The ONNX opset version in which to register.\nUnregisterssymbolic_name.\nsymbolic_name\nSee \u201cCustom Operators\u201d in the module documentation for an example usage.\nsymbolic_name(str) \u2013 The name of the custom operator in \u201c<domain>::<op>\u201d\nformat.\nopset_version(int) \u2013 The ONNX opset version in which to unregister.\nA context manager to temporarily set the training mode ofmodeltomode, resetting it when we exit the with-block.\nmodel\nmode\nDeprecated since version 2.7:Please set training mode before exporting the model.\nmodel\u2013 Same type and meaning asmodelarg toexport().\nmodel\nexport()\nmode(TrainingMode) \u2013 Same type and meaning astrainingarg toexport().\ntraining\nexport()",
  "url": "https://pytorch.org/docs/stable/onnx.html",
  "metadata": {
    "section": null,
    "issue_number": null,
    "labels": null,
    "answer_author": null
  }
}